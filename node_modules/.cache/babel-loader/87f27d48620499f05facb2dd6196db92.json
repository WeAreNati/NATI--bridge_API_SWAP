{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar base58check = require('bs58check');\nvar bcrypto = require('./crypto');\nvar createHmac = require('create-hmac');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar NETWORKS = require('./networks');\nvar BigInteger = require('bigi');\nvar ECPair = require('./ecpair');\nvar ecurve = require('ecurve');\nvar curve = ecurve.getCurveByName('secp256k1');\nvar fastcurve = require('./fastcurve');\nfunction HDNode(keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs');\n  this.keyPair = keyPair;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.parentFingerprint = 0x00000000;\n  this.derivationCache = {};\n}\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n  var pIL = BigInteger.fromBuffer(IL);\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  });\n  return new HDNode(keyPair, IR);\n};\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string);\n  if (buffer.length !== 78) throw new Error('Invalid buffer length');\n  // 4 bytes: version bytes\n  var version = buffer.readUInt32BE(0);\n  var network;\n  // list of networks?\n  if (Array.isArray(networks)) {\n    // FIXME(BG-16845):\n    // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.\n    // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.\n    network = networks.filter(function (x) {\n      return version === x.bip32.private || version === x.bip32.public;\n    }).pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin;\n  }\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new Error('Invalid network version');\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  var depth = buffer[4];\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  var parentFingerprint = buffer.readUInt32BE(5);\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint');\n  }\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new Error('Invalid index');\n  // 32 bytes: the chain code\n  var chainCode = buffer.slice(13, 45);\n  var keyPair;\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key');\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n    keyPair = new ECPair(d, null, {\n      network: network\n    });\n    // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78));\n    // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n    curve.validate(Q);\n    keyPair = new ECPair(null, Q, {\n      network: network\n    });\n  }\n  var hd = new HDNode(keyPair, chainCode);\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n};\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress();\n};\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4);\n};\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork();\n};\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer();\n};\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  });\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash);\n};\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature);\n};\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0');\n  // Version\n  var network = this.keyPair.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78);\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0);\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4);\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5);\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9);\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13);\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.keyPair.d.toBuffer(32).copy(buffer, 46);\n    // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n  }\n  return base58check.encode(buffer);\n};\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index);\n  var isHardened = index >= HDNode.HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37);\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key');\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00;\n    this.keyPair.d.toBuffer(32).copy(data, 1);\n    data.writeUInt32BE(index, 33);\n    // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n  var I = createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var pIL = BigInteger.fromBuffer(IL);\n  // In case parse256(IL) >= n, proceed with the next value for i\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1);\n  }\n  // Private parent key -> private child key\n  var derivedKeyPair;\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n);\n    // In case ki == 0, proceed with the next value for i\n    if (ki.signum() === 0) {\n      return this.derive(index + 1);\n    }\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    });\n    // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var point = fastcurve.publicKeyCreate(IL, false);\n    var Ki = point !== undefined ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q) : curve.G.multiply(pIL).add(this.keyPair.Q);\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1);\n    }\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    });\n  }\n  var hd = new HDNode(derivedKeyPair, IR);\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n  return hd;\n};\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index);\n  // Only derives hardened private keys by default\n  return this.derive(index + HDNode.HIGHEST_BIT);\n};\n// Private === not neutered\n// Public === neutered\nHDNode.prototype.isNeutered = function () {\n  return !this.keyPair.d;\n};\nHDNode.prototype.derivePath = function (path, cache) {\n  typeforce(types.BIP32Path, path);\n  typeforce(types.maybe(types.Object), cache);\n  cache = cache || this.derivationCache;\n  var splitPath = path.split('/');\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node');\n    }\n    splitPath = splitPath.slice(1);\n  }\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n    var cacheObject = cache[indexStr] || {};\n    if (cacheObject.node) {\n      cache = cacheObject.next;\n      return cacheObject.node;\n    }\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      cacheObject.node = prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      cacheObject.node = prevHd.derive(index);\n    }\n    cache[indexStr] = cacheObject;\n    cacheObject.next = {};\n    cache = cacheObject.next;\n    return cacheObject.node;\n  }, this);\n};\n/**\n * Create a new ECPair object from this HDNode's ECPair.\n *\n * Uses secp256k1 if available for accelerated computation of the cloned public key.\n * @return {ECPair}\n */\nHDNode.prototype.cloneKeypair = function () {\n  var k = this.keyPair;\n  var result = new ECPair(k.d, k.d ? null : k.Q, {\n    network: k.network,\n    compressed: k.compressed\n  });\n  // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute\n  // if Q is not set here, it will be lazily computed via the slow path\n  if (!result.__Q) {\n    var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false);\n    if (point !== undefined) {\n      result.__Q = ecurve.Point.decodeFrom(curve, point);\n    }\n  }\n  return result;\n};\nmodule.exports = HDNode;","map":{"version":3,"names":["Buffer","require","base58check","bcrypto","createHmac","typeforce","types","NETWORKS","BigInteger","ECPair","ecurve","curve","getCurveByName","fastcurve","HDNode","keyPair","chainCode","tuple","Buffer256bit","arguments","compressed","TypeError","depth","index","parentFingerprint","derivationCache","HIGHEST_BIT","LENGTH","MASTER_SECRET","from","fromSeedBuffer","seed","network","maybe","Network","length","I","update","digest","IL","slice","IR","pIL","fromBuffer","fromSeedHex","hex","fromBase58","string","networks","buffer","decode","Error","version","readUInt32BE","Array","isArray","filter","x","bip32","private","public","pop","bitcoin","readUInt8","d","Q","Point","decodeFrom","validate","hd","prototype","getAddress","getIdentifier","hash160","getPublicKeyBuffer","getFingerprint","getNetwork","neutered","neuteredKeyPair","sign","hash","verify","signature","toBase58","__isPrivate","undefined","isNeutered","allocUnsafe","writeUInt32BE","writeUInt8","copy","toBuffer","encode","derive","UInt32","isHardened","data","compareTo","n","derivedKeyPair","ki","add","mod","signum","point","publicKeyCreate","Ki","G","multiply","isInfinity","deriveHardened","UInt31","derivePath","path","cache","BIP32Path","Object","splitPath","split","reduce","prevHd","indexStr","cacheObject","node","next","parseInt","cloneKeypair","k","result","__Q","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/hdnode.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar base58check = require('bs58check');\nvar bcrypto = require('./crypto');\nvar createHmac = require('create-hmac');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar NETWORKS = require('./networks');\nvar BigInteger = require('bigi');\nvar ECPair = require('./ecpair');\nvar ecurve = require('ecurve');\nvar curve = ecurve.getCurveByName('secp256k1');\nvar fastcurve = require('./fastcurve');\nfunction HDNode(keyPair, chainCode) {\n    typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);\n    if (!keyPair.compressed)\n        throw new TypeError('BIP32 only allows compressed keyPairs');\n    this.keyPair = keyPair;\n    this.chainCode = chainCode;\n    this.depth = 0;\n    this.index = 0;\n    this.parentFingerprint = 0x00000000;\n    this.derivationCache = {};\n}\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\nHDNode.fromSeedBuffer = function (seed, network) {\n    typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n    var IL = I.slice(0, 32);\n    var IR = I.slice(32);\n    // In case IL is 0 or >= n, the master key is invalid\n    // This is handled by the ECPair constructor\n    var pIL = BigInteger.fromBuffer(IL);\n    var keyPair = new ECPair(pIL, null, {\n        network: network\n    });\n    return new HDNode(keyPair, IR);\n};\nHDNode.fromSeedHex = function (hex, network) {\n    return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\nHDNode.fromBase58 = function (string, networks) {\n    var buffer = base58check.decode(string);\n    if (buffer.length !== 78)\n        throw new Error('Invalid buffer length');\n    // 4 bytes: version bytes\n    var version = buffer.readUInt32BE(0);\n    var network;\n    // list of networks?\n    if (Array.isArray(networks)) {\n        // FIXME(BG-16845):\n        // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.\n        // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.\n        network = networks.filter(function (x) {\n            return version === x.bip32.private ||\n                version === x.bip32.public;\n        }).pop();\n        if (!network)\n            throw new Error('Unknown network version');\n        // otherwise, assume a network object (or default to bitcoin)\n    }\n    else {\n        network = networks || NETWORKS.bitcoin;\n    }\n    if (version !== network.bip32.private &&\n        version !== network.bip32.public)\n        throw new Error('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    var depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    var parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new Error('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    var index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new Error('Invalid index');\n    // 32 bytes: the chain code\n    var chainCode = buffer.slice(13, 45);\n    var keyPair;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new Error('Invalid private key');\n        var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n        keyPair = new ECPair(d, null, { network: network });\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78));\n        // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n        // Verify that the X coordinate in the public point corresponds to a point on the curve.\n        // If not, the extended public key is invalid.\n        curve.validate(Q);\n        keyPair = new ECPair(null, Q, { network: network });\n    }\n    var hd = new HDNode(keyPair, chainCode);\n    hd.depth = depth;\n    hd.index = index;\n    hd.parentFingerprint = parentFingerprint;\n    return hd;\n};\nHDNode.prototype.getAddress = function () {\n    return this.keyPair.getAddress();\n};\nHDNode.prototype.getIdentifier = function () {\n    return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\nHDNode.prototype.getFingerprint = function () {\n    return this.getIdentifier().slice(0, 4);\n};\nHDNode.prototype.getNetwork = function () {\n    return this.keyPair.getNetwork();\n};\nHDNode.prototype.getPublicKeyBuffer = function () {\n    return this.keyPair.getPublicKeyBuffer();\n};\nHDNode.prototype.neutered = function () {\n    var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n        network: this.keyPair.network\n    });\n    var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n    neutered.depth = this.depth;\n    neutered.index = this.index;\n    neutered.parentFingerprint = this.parentFingerprint;\n    return neutered;\n};\nHDNode.prototype.sign = function (hash) {\n    return this.keyPair.sign(hash);\n};\nHDNode.prototype.verify = function (hash, signature) {\n    return this.keyPair.verify(hash, signature);\n};\nHDNode.prototype.toBase58 = function (__isPrivate) {\n    if (__isPrivate !== undefined)\n        throw new TypeError('Unsupported argument in 2.0.0');\n    // Version\n    var network = this.keyPair.network;\n    var version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public;\n    var buffer = Buffer.allocUnsafe(78);\n    // 4 bytes: version bytes\n    buffer.writeUInt32BE(version, 0);\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n    buffer.writeUInt8(this.depth, 4);\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    buffer.writeUInt32BE(this.parentFingerprint, 5);\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in big endian. (0x00000000 if master key)\n    buffer.writeUInt32BE(this.index, 9);\n    // 32 bytes: the chain code\n    this.chainCode.copy(buffer, 13);\n    // 33 bytes: the public key or private key data\n    if (!this.isNeutered()) {\n        // 0x00 + k for private keys\n        buffer.writeUInt8(0, 45);\n        this.keyPair.d.toBuffer(32).copy(buffer, 46);\n        // 33 bytes: the public key\n    }\n    else {\n        // X9.62 encoding for public keys\n        this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n    }\n    return base58check.encode(buffer);\n};\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nHDNode.prototype.derive = function (index) {\n    typeforce(types.UInt32, index);\n    var isHardened = index >= HDNode.HIGHEST_BIT;\n    var data = Buffer.allocUnsafe(37);\n    // Hardened child\n    if (isHardened) {\n        if (this.isNeutered())\n            throw new TypeError('Could not derive hardened child key');\n        // data = 0x00 || ser256(kpar) || ser32(index)\n        data[0] = 0x00;\n        this.keyPair.d.toBuffer(32).copy(data, 1);\n        data.writeUInt32BE(index, 33);\n        // Normal child\n    }\n    else {\n        // data = serP(point(kpar)) || ser32(index)\n        //      = serP(Kpar) || ser32(index)\n        this.keyPair.getPublicKeyBuffer().copy(data, 0);\n        data.writeUInt32BE(index, 33);\n    }\n    var I = createHmac('sha512', this.chainCode).update(data).digest();\n    var IL = I.slice(0, 32);\n    var IR = I.slice(32);\n    var pIL = BigInteger.fromBuffer(IL);\n    // In case parse256(IL) >= n, proceed with the next value for i\n    if (pIL.compareTo(curve.n) >= 0) {\n        return this.derive(index + 1);\n    }\n    // Private parent key -> private child key\n    var derivedKeyPair;\n    if (!this.isNeutered()) {\n        // ki = parse256(IL) + kpar (mod n)\n        var ki = pIL.add(this.keyPair.d).mod(curve.n);\n        // In case ki == 0, proceed with the next value for i\n        if (ki.signum() === 0) {\n            return this.derive(index + 1);\n        }\n        derivedKeyPair = new ECPair(ki, null, {\n            network: this.keyPair.network\n        });\n        // Public parent key -> public child key\n    }\n    else {\n        // Ki = point(parse256(IL)) + Kpar\n        //    = G*IL + Kpar\n        var point = fastcurve.publicKeyCreate(IL, false);\n        var Ki = point !== undefined\n            ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q)\n            : curve.G.multiply(pIL).add(this.keyPair.Q);\n        // In case Ki is the point at infinity, proceed with the next value for i\n        if (curve.isInfinity(Ki)) {\n            return this.derive(index + 1);\n        }\n        derivedKeyPair = new ECPair(null, Ki, {\n            network: this.keyPair.network\n        });\n    }\n    var hd = new HDNode(derivedKeyPair, IR);\n    hd.depth = this.depth + 1;\n    hd.index = index;\n    hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n    return hd;\n};\nHDNode.prototype.deriveHardened = function (index) {\n    typeforce(types.UInt31, index);\n    // Only derives hardened private keys by default\n    return this.derive(index + HDNode.HIGHEST_BIT);\n};\n// Private === not neutered\n// Public === neutered\nHDNode.prototype.isNeutered = function () {\n    return !(this.keyPair.d);\n};\nHDNode.prototype.derivePath = function (path, cache) {\n    typeforce(types.BIP32Path, path);\n    typeforce(types.maybe(types.Object), cache);\n    cache = cache || this.derivationCache;\n    var splitPath = path.split('/');\n    if (splitPath[0] === 'm') {\n        if (this.parentFingerprint) {\n            throw new Error('Not a master node');\n        }\n        splitPath = splitPath.slice(1);\n    }\n    return splitPath.reduce(function (prevHd, indexStr) {\n        var index;\n        var cacheObject = cache[indexStr] || {};\n        if (cacheObject.node) {\n            cache = cacheObject.next;\n            return cacheObject.node;\n        }\n        if (indexStr.slice(-1) === \"'\") {\n            index = parseInt(indexStr.slice(0, -1), 10);\n            cacheObject.node = prevHd.deriveHardened(index);\n        }\n        else {\n            index = parseInt(indexStr, 10);\n            cacheObject.node = prevHd.derive(index);\n        }\n        cache[indexStr] = cacheObject;\n        cacheObject.next = {};\n        cache = cacheObject.next;\n        return cacheObject.node;\n    }, this);\n};\n/**\n * Create a new ECPair object from this HDNode's ECPair.\n *\n * Uses secp256k1 if available for accelerated computation of the cloned public key.\n * @return {ECPair}\n */\nHDNode.prototype.cloneKeypair = function () {\n    var k = this.keyPair;\n    var result = new ECPair(k.d, k.d ? null : k.Q, {\n        network: k.network,\n        compressed: k.compressed\n    });\n    // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute\n    // if Q is not set here, it will be lazily computed via the slow path\n    if (!result.__Q) {\n        var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false);\n        if (point !== undefined) {\n            result.__Q = ecurve.Point.decodeFrom(curve, point);\n        }\n    }\n    return result;\n};\nmodule.exports = HDNode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}