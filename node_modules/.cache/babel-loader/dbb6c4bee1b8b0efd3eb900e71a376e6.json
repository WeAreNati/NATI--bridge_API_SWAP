{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar bscript = require('./script');\nvar varuint = require('varuint-bitcoin');\nvar SmartTransactionSignature = require('./smart_transaction_signature');\nvar SmartTransactionSignatures = /** @class */function () {\n  function SmartTransactionSignatures(version, sigHashType, signatures) {\n    if (version === void 0) {\n      version = 1;\n    }\n    if (sigHashType === void 0) {\n      sigHashType = 1;\n    }\n    this.version = version;\n    this.sigHashType = sigHashType;\n    this.signatures = signatures || [];\n    this.error = null;\n  }\n  SmartTransactionSignatures.prototype.isValid = function () {\n    return this.version > 0 && this.version < 2 && bscript.isDefinedHashType(this.sigHashType) && this.signatures.length > 0;\n  };\n  SmartTransactionSignatures.prototype.__byteLength = function () {\n    return this.signatures.reduce(function (a, x) {\n      return a + x.__byteLength();\n    }, 2 + varuint.encodingLength(this.signatures.length));\n  };\n  SmartTransactionSignatures.prototype.minLength = function () {\n    var checkSigs = new SmartTransactionSignatures();\n    return checkSigs.__byteLength();\n  };\n  SmartTransactionSignatures.prototype.toBuffer = function (buffer, initialOffset) {\n    var noBuffer = !buffer;\n    if (noBuffer) buffer = Buffer.allocUnsafe(this.__byteLength());\n    var offset = initialOffset || 0;\n    function writeUInt8(i) {\n      offset = buffer.writeUInt8(i, offset);\n    }\n    function writeVarInt(i) {\n      varuint.encode(i, buffer, offset);\n      offset += varuint.encode.bytes;\n    }\n    writeUInt8(this.version);\n    writeUInt8(this.sigHashType);\n    writeVarInt(this.signatures ? this.signatures.length : 0);\n    this.signatures.forEach(function (x) {\n      offset = x.toBuffer(buffer, offset);\n    });\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined) return noBuffer ? buffer.slice(initialOffset, offset) : offset;\n    // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n    return noBuffer ? buffer.slice(0, offset) : offset;\n  };\n  SmartTransactionSignatures.fromChunk = function (chunk) {\n    var sigs = new SmartTransactionSignatures();\n    sigs.fromBuffer(chunk);\n    return sigs;\n  };\n  SmartTransactionSignatures.prototype.toChunk = function () {\n    return this.toBuffer();\n  };\n  SmartTransactionSignatures.prototype.fromBuffer = function (buffer, initialOffset) {\n    if (initialOffset === void 0) {\n      initialOffset = 0;\n    }\n    var offset = initialOffset;\n    function readUInt8() {\n      var i = buffer.readUInt8(offset);\n      offset += 1;\n      return i;\n    }\n    function readVarInt() {\n      var vi = varuint.decode(buffer, offset);\n      offset += varuint.decode.bytes;\n      return vi;\n    }\n    function readOneSig() {\n      var oneSig = new SmartTransactionSignature();\n      offset = oneSig.fromBuffer(buffer, offset);\n      return oneSig;\n    }\n    try {\n      if (buffer.length < this.minLength()) {\n        this.error = new Error('buffer length too short');\n        return initialOffset;\n      }\n      this.version = readUInt8();\n      this.sigHashType = readUInt8();\n      if (!(this.version > 0 && this.version < 2 && bscript.isDefinedHashType(this.sigHashType))) {\n        return initialOffset;\n      }\n      this.signatures = this.signatures ? this.signatures : [];\n      for (var numSignatures = readVarInt(); numSignatures > 0; numSignatures--) {\n        this.signatures[this.signatures.length] = readOneSig();\n      }\n    } catch (error) {\n      this.error = error;\n      this.version = 0;\n      return initialOffset;\n    }\n    return offset;\n  };\n  return SmartTransactionSignatures;\n}();\nmodule.exports = SmartTransactionSignatures;","map":{"version":3,"names":["Buffer","require","bscript","varuint","SmartTransactionSignature","SmartTransactionSignatures","version","sigHashType","signatures","error","prototype","isValid","isDefinedHashType","length","__byteLength","reduce","a","x","encodingLength","minLength","checkSigs","toBuffer","buffer","initialOffset","noBuffer","allocUnsafe","offset","writeUInt8","i","writeVarInt","encode","bytes","forEach","undefined","slice","fromChunk","chunk","sigs","fromBuffer","toChunk","readUInt8","readVarInt","vi","decode","readOneSig","oneSig","Error","numSignatures","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/smart_transaction_signatures.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar bscript = require('./script');\nvar varuint = require('varuint-bitcoin');\nvar SmartTransactionSignature = require('./smart_transaction_signature');\nvar SmartTransactionSignatures = /** @class */ (function () {\n    function SmartTransactionSignatures(version, sigHashType, signatures) {\n        if (version === void 0) { version = 1; }\n        if (sigHashType === void 0) { sigHashType = 1; }\n        this.version = version;\n        this.sigHashType = sigHashType;\n        this.signatures = signatures || [];\n        this.error = null;\n    }\n    SmartTransactionSignatures.prototype.isValid = function () {\n        return this.version > 0 && this.version < 2 && bscript.isDefinedHashType(this.sigHashType) && this.signatures.length > 0;\n    };\n    SmartTransactionSignatures.prototype.__byteLength = function () {\n        return this.signatures.reduce(function (a, x) { return a + x.__byteLength(); }, 2 + varuint.encodingLength(this.signatures.length));\n    };\n    SmartTransactionSignatures.prototype.minLength = function () {\n        var checkSigs = new SmartTransactionSignatures();\n        return checkSigs.__byteLength();\n    };\n    SmartTransactionSignatures.prototype.toBuffer = function (buffer, initialOffset) {\n        var noBuffer = !buffer;\n        if (noBuffer)\n            buffer = Buffer.allocUnsafe(this.__byteLength());\n        var offset = initialOffset || 0;\n        function writeUInt8(i) { offset = buffer.writeUInt8(i, offset); }\n        function writeVarInt(i) {\n            varuint.encode(i, buffer, offset);\n            offset += varuint.encode.bytes;\n        }\n        writeUInt8(this.version);\n        writeUInt8(this.sigHashType);\n        writeVarInt(this.signatures ? this.signatures.length : 0);\n        this.signatures.forEach(function (x) {\n            offset = x.toBuffer(buffer, offset);\n        });\n        // avoid slicing unless necessary\n        if (initialOffset !== undefined)\n            return noBuffer ? buffer.slice(initialOffset, offset) : offset;\n        // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n        return noBuffer ? buffer.slice(0, offset) : offset;\n    };\n    SmartTransactionSignatures.fromChunk = function (chunk) {\n        var sigs = new SmartTransactionSignatures();\n        sigs.fromBuffer(chunk);\n        return sigs;\n    };\n    SmartTransactionSignatures.prototype.toChunk = function () {\n        return this.toBuffer();\n    };\n    SmartTransactionSignatures.prototype.fromBuffer = function (buffer, initialOffset) {\n        if (initialOffset === void 0) { initialOffset = 0; }\n        var offset = initialOffset;\n        function readUInt8() {\n            var i = buffer.readUInt8(offset);\n            offset += 1;\n            return i;\n        }\n        function readVarInt() {\n            var vi = varuint.decode(buffer, offset);\n            offset += varuint.decode.bytes;\n            return vi;\n        }\n        function readOneSig() {\n            var oneSig = new SmartTransactionSignature();\n            offset = oneSig.fromBuffer(buffer, offset);\n            return oneSig;\n        }\n        try {\n            if (buffer.length < this.minLength()) {\n                this.error = new Error('buffer length too short');\n                return initialOffset;\n            }\n            this.version = readUInt8();\n            this.sigHashType = readUInt8();\n            if (!(this.version > 0 && this.version < 2 && bscript.isDefinedHashType(this.sigHashType))) {\n                return initialOffset;\n            }\n            this.signatures = this.signatures ? this.signatures : [];\n            for (var numSignatures = readVarInt(); numSignatures > 0; numSignatures--) {\n                this.signatures[this.signatures.length] = readOneSig();\n            }\n        }\n        catch (error) {\n            this.error = error;\n            this.version = 0;\n            return initialOffset;\n        }\n        return offset;\n    };\n    return SmartTransactionSignatures;\n}());\nmodule.exports = SmartTransactionSignatures;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}