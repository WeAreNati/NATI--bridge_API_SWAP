{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDefinedHashType = exports.isCanonicalPubKey = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.asMinimalOP = exports.isPushOnly = exports.isPushOnlyChunk = exports.isOPInt = void 0;\nconst pushdata = require(\"./pushdata\");\nconst ops_1 = require(\"./ops\");\nconst reverseops_1 = require(\"./reverseops\");\nconst string_1 = require(\"./string\");\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE;\n}\nexports.isOPInt = isOPInt;\nfunction isPushOnlyChunk(value) {\n  return Buffer.isBuffer(value) || isOPInt(value);\n}\nexports.isPushOnlyChunk = isPushOnlyChunk;\nfunction isPushOnly(value) {\n  return value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nexports.asMinimalOP = asMinimalOP;\nfunction compile(chunks) {\n  if (Buffer.isBuffer(chunks)) return chunks;\n  const bufferSize = chunks.reduce(function (accum, chunk) {\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    } else {\n      // opcode\n      return accum + 1;\n    }\n  }, 0.0);\n  var buffer = Buffer.alloc(bufferSize);\n  var offset = 0;\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  if (Array.isArray(buffer)) return buffer;\n  var chunks = [];\n  var i = 0;\n  while (i < buffer.length) {\n    var opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail? empty script\n      if (d === null) return [];\n      i += d.size;\n      // attempt to read too much data? empty script\n      if (i + d.number > buffer.length) return [];\n      var data = buffer.subarray(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      var op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks.map(function (chunk) {\n    // data?\n    if (Buffer.isBuffer(chunk)) {\n      var op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString('hex');\n      chunk = op;\n    }\n    // opcode!\n    return reverseops_1.default[chunk];\n  }).join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  return compile(asm.split(' ').map(function (chunkStr) {\n    // opcode?\n    if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n    if (!(0, string_1.isHexString)(chunkStr)) throw new Error(\"Expected hex in fromASM\");\n    // data!\n    return Buffer.from(chunkStr, 'hex');\n  }));\n}\nexports.fromASM = fromASM;\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n    case 0x04:\n      return buffer.length === 65;\n  }\n  return false;\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;","map":{"version":3,"names":["Object","defineProperty","exports","value","isDefinedHashType","isCanonicalPubKey","fromASM","toASM","decompile","compile","asMinimalOP","isPushOnly","isPushOnlyChunk","isOPInt","pushdata","require","ops_1","reverseops_1","string_1","OP_INT_BASE","OPS","OP_RESERVED","OP_0","OP_1","OP_16","OP_1NEGATE","Buffer","isBuffer","every","buffer","length","chunks","bufferSize","reduce","accum","chunk","undefined","encodingLength","alloc","offset","forEach","opcode","writeUInt8","encode","copy","Error","Array","isArray","i","OP_PUSHDATA4","d","decode","size","number","data","subarray","op","push","map","toString","default","join","asm","split","chunkStr","isHexString","from","hashType","hashTypeMod"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/utils/script.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isDefinedHashType = exports.isCanonicalPubKey = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.asMinimalOP = exports.isPushOnly = exports.isPushOnlyChunk = exports.isOPInt = void 0;\nconst pushdata = require(\"./pushdata\");\nconst ops_1 = require(\"./ops\");\nconst reverseops_1 = require(\"./reverseops\");\nconst string_1 = require(\"./string\");\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n    return ((value === ops_1.OPS.OP_0) ||\n        (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n        (value === ops_1.OPS.OP_1NEGATE));\n}\nexports.isOPInt = isOPInt;\nfunction isPushOnlyChunk(value) {\n    return Buffer.isBuffer(value) || isOPInt(value);\n}\nexports.isPushOnlyChunk = isPushOnlyChunk;\nfunction isPushOnly(value) {\n    return value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n    if (buffer.length === 0)\n        return ops_1.OPS.OP_0;\n    if (buffer.length !== 1)\n        return;\n    if (buffer[0] >= 1 && buffer[0] <= 16)\n        return OP_INT_BASE + buffer[0];\n    if (buffer[0] === 0x81)\n        return ops_1.OPS.OP_1NEGATE;\n}\nexports.asMinimalOP = asMinimalOP;\nfunction compile(chunks) {\n    if (Buffer.isBuffer(chunks))\n        return chunks;\n    const bufferSize = chunks.reduce(function (accum, chunk) {\n        if (Buffer.isBuffer(chunk)) {\n            // adhere to BIP62.3, minimal push policy\n            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n                return accum + 1;\n            }\n            return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n        }\n        else {\n            // opcode\n            return accum + 1;\n        }\n    }, 0.0);\n    var buffer = Buffer.alloc(bufferSize);\n    var offset = 0;\n    chunks.forEach(function (chunk) {\n        // data chunk\n        if (Buffer.isBuffer(chunk)) {\n            // adhere to BIP62.3, minimal push policy\n            var opcode = asMinimalOP(chunk);\n            if (opcode !== undefined) {\n                buffer.writeUInt8(opcode, offset);\n                offset += 1;\n                return;\n            }\n            offset += pushdata.encode(buffer, chunk.length, offset);\n            chunk.copy(buffer, offset);\n            offset += chunk.length;\n            // opcode\n        }\n        else {\n            buffer.writeUInt8(chunk, offset);\n            offset += 1;\n        }\n    });\n    if (offset !== buffer.length)\n        throw new Error('Could not decode chunks');\n    return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n    if (Array.isArray(buffer))\n        return buffer;\n    var chunks = [];\n    var i = 0;\n    while (i < buffer.length) {\n        var opcode = buffer[i];\n        // data chunk\n        if ((opcode > ops_1.OPS.OP_0) && (opcode <= ops_1.OPS.OP_PUSHDATA4)) {\n            var d = pushdata.decode(buffer, i);\n            // did reading a pushDataInt fail? empty script\n            if (d === null)\n                return [];\n            i += d.size;\n            // attempt to read too much data? empty script\n            if (i + d.number > buffer.length)\n                return [];\n            var data = buffer.subarray(i, i + d.number);\n            i += d.number;\n            // decompile minimally\n            var op = asMinimalOP(data);\n            if (op !== undefined) {\n                chunks.push(op);\n            }\n            else {\n                chunks.push(data);\n            }\n        }\n        else {\n            chunks.push(opcode);\n            i += 1;\n        }\n    }\n    return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n    if (Buffer.isBuffer(chunks)) {\n        chunks = decompile(chunks);\n    }\n    return chunks.map(function (chunk) {\n        // data?\n        if (Buffer.isBuffer(chunk)) {\n            var op = asMinimalOP(chunk);\n            if (op === undefined)\n                return chunk.toString('hex');\n            chunk = op;\n        }\n        // opcode!\n        return reverseops_1.default[chunk];\n    }).join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n    return compile(asm.split(' ').map(function (chunkStr) {\n        // opcode?\n        if (ops_1.OPS[chunkStr] !== undefined)\n            return ops_1.OPS[chunkStr];\n        if (!(0, string_1.isHexString)(chunkStr))\n            throw new Error(\"Expected hex in fromASM\");\n        // data!\n        return Buffer.from(chunkStr, 'hex');\n    }));\n}\nexports.fromASM = fromASM;\nfunction isCanonicalPubKey(buffer) {\n    if (!Buffer.isBuffer(buffer))\n        return false;\n    if (buffer.length < 33)\n        return false;\n    switch (buffer[0]) {\n        case 0x02:\n        case 0x03:\n            return buffer.length === 33;\n        case 0x04:\n            return buffer.length === 65;\n    }\n    return false;\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n    var hashTypeMod = hashType & ~0xc0;\n    return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}