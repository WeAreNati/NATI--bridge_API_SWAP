{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar createHmac = require('create-hmac');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar BigInteger = require('bigi');\nvar ECSignature = require('./ecsignature');\nvar ZERO = Buffer.alloc(1, 0);\nvar ONE = Buffer.alloc(1, 1);\nvar ecurve = require('ecurve');\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(hash, x, checkSig) {\n  typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments);\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  var k = Buffer.alloc(32, 0);\n  var v = Buffer.alloc(32, 1);\n  // Step D\n  k = createHmac('sha256', k).update(v).update(ZERO).update(x).update(hash).digest();\n  // Step E\n  v = createHmac('sha256', k).update(v).digest();\n  // Step F\n  k = createHmac('sha256', k).update(v).update(ONE).update(x).update(hash).digest();\n  // Step G\n  v = createHmac('sha256', k).update(v).digest();\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest();\n  var T = BigInteger.fromBuffer(v);\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO).digest();\n    v = createHmac('sha256', k).update(v).digest();\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest();\n    T = BigInteger.fromBuffer(v);\n  }\n  return T;\n}\nvar N_OVER_TWO = secp256k1.n.shiftRight(1);\nfunction sign(hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);\n  var x = d.toBuffer(32);\n  var e = BigInteger.fromBuffer(hash);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r, s;\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k);\n    if (secp256k1.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  });\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n  return new ECSignature(r, s);\n}\nfunction verify(hash, signature, Q) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s;\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  // Compute s^-1\n  var sInv = s.modInverse(n);\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(sInv).mod(n);\n  var u2 = r.multiply(sInv).mod(n);\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2);\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (secp256k1.isInfinity(R)) return false;\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX;\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n);\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r);\n}\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  // TODO: remove\n  __curve: secp256k1\n};","map":{"version":3,"names":["Buffer","require","createHmac","typeforce","types","BigInteger","ECSignature","ZERO","alloc","ONE","ecurve","secp256k1","getCurveByName","deterministicGenerateK","hash","x","checkSig","tuple","Hash256bit","Buffer256bit","Function","arguments","k","v","update","digest","T","fromBuffer","signum","compareTo","n","N_OVER_TWO","shiftRight","sign","d","BigInt","toBuffer","e","G","r","s","Q","multiply","isInfinity","affineX","mod","modInverse","add","subtract","verify","signature","ECPoint","sInv","u1","u2","R","multiplyTwo","xR","equals","module","exports","__curve"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/ecdsa.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar createHmac = require('create-hmac');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar BigInteger = require('bigi');\nvar ECSignature = require('./ecsignature');\nvar ZERO = Buffer.alloc(1, 0);\nvar ONE = Buffer.alloc(1, 1);\nvar ecurve = require('ecurve');\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(hash, x, checkSig) {\n    typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments);\n    // Step A, ignored as hash already provided\n    // Step B\n    // Step C\n    var k = Buffer.alloc(32, 0);\n    var v = Buffer.alloc(32, 1);\n    // Step D\n    k = createHmac('sha256', k)\n        .update(v)\n        .update(ZERO)\n        .update(x)\n        .update(hash)\n        .digest();\n    // Step E\n    v = createHmac('sha256', k).update(v).digest();\n    // Step F\n    k = createHmac('sha256', k)\n        .update(v)\n        .update(ONE)\n        .update(x)\n        .update(hash)\n        .digest();\n    // Step G\n    v = createHmac('sha256', k).update(v).digest();\n    // Step H1/H2a, ignored as tlen === qlen (256 bit)\n    // Step H2b\n    v = createHmac('sha256', k).update(v).digest();\n    var T = BigInteger.fromBuffer(v);\n    // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n    while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n        k = createHmac('sha256', k)\n            .update(v)\n            .update(ZERO)\n            .digest();\n        v = createHmac('sha256', k).update(v).digest();\n        // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n        // Step H2b again\n        v = createHmac('sha256', k).update(v).digest();\n        T = BigInteger.fromBuffer(v);\n    }\n    return T;\n}\nvar N_OVER_TWO = secp256k1.n.shiftRight(1);\nfunction sign(hash, d) {\n    typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);\n    var x = d.toBuffer(32);\n    var e = BigInteger.fromBuffer(hash);\n    var n = secp256k1.n;\n    var G = secp256k1.G;\n    var r, s;\n    deterministicGenerateK(hash, x, function (k) {\n        var Q = G.multiply(k);\n        if (secp256k1.isInfinity(Q))\n            return false;\n        r = Q.affineX.mod(n);\n        if (r.signum() === 0)\n            return false;\n        s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n        if (s.signum() === 0)\n            return false;\n        return true;\n    });\n    // enforce low S values, see bip62: 'low s values in signatures'\n    if (s.compareTo(N_OVER_TWO) > 0) {\n        s = n.subtract(s);\n    }\n    return new ECSignature(r, s);\n}\nfunction verify(hash, signature, Q) {\n    typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);\n    var n = secp256k1.n;\n    var G = secp256k1.G;\n    var r = signature.r;\n    var s = signature.s;\n    // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n    if (r.signum() <= 0 || r.compareTo(n) >= 0)\n        return false;\n    if (s.signum() <= 0 || s.compareTo(n) >= 0)\n        return false;\n    // 1.4.2 H = Hash(M), already done by the user\n    // 1.4.3 e = H\n    var e = BigInteger.fromBuffer(hash);\n    // Compute s^-1\n    var sInv = s.modInverse(n);\n    // 1.4.4 Compute u1 = es^−1 mod n\n    //               u2 = rs^−1 mod n\n    var u1 = e.multiply(sInv).mod(n);\n    var u2 = r.multiply(sInv).mod(n);\n    // 1.4.5 Compute R = (xR, yR)\n    //               R = u1G + u2Q\n    var R = G.multiplyTwo(u1, Q, u2);\n    // 1.4.5 (cont.) Enforce R is not at infinity\n    if (secp256k1.isInfinity(R))\n        return false;\n    // 1.4.6 Convert the field element R.x to an integer\n    var xR = R.affineX;\n    // 1.4.7 Set v = xR mod n\n    var v = xR.mod(n);\n    // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n    return v.equals(r);\n}\nmodule.exports = {\n    deterministicGenerateK: deterministicGenerateK,\n    sign: sign,\n    verify: verify,\n    // TODO: remove\n    __curve: secp256k1\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}