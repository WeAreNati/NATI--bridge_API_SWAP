{"ast":null,"code":"const assert = require('nanoassert');\nconst wasm = require('./blake2b')();\nlet head = 64;\nconst freeList = [];\nmodule.exports = Blake2b;\nconst BYTES_MIN = module.exports.BYTES_MIN = 16;\nconst BYTES_MAX = module.exports.BYTES_MAX = 64;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst BYTES = module.exports.BYTES = 32;\nconst KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;\nconst KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst KEYBYTES = module.exports.KEYBYTES = 32;\nconst SALTBYTES = module.exports.SALTBYTES = 16;\nconst PERSONALBYTES = module.exports.PERSONALBYTES = 16;\nfunction Blake2b(digestLength, key, salt, personal, noAssert) {\n  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);\n  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');\n  if (!digestLength) digestLength = 32;\n  if (noAssert !== true) {\n    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);\n    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);\n    if (key != null) {\n      assert(key instanceof Uint8Array, 'key must be Uint8Array or Buffer');\n      assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);\n      assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);\n    }\n    if (salt != null) {\n      assert(salt instanceof Uint8Array, 'salt must be Uint8Array or Buffer');\n      assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);\n    }\n    if (personal != null) {\n      assert(personal instanceof Uint8Array, 'personal must be Uint8Array or Buffer');\n      assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);\n    }\n  }\n  if (!freeList.length) {\n    freeList.push(head);\n    head += 216;\n  }\n  this.digestLength = digestLength;\n  this.finalized = false;\n  this.pointer = freeList.pop();\n  wasm.memory.fill(0, 0, 64);\n  wasm.memory[0] = this.digestLength;\n  wasm.memory[1] = key ? key.length : 0;\n  wasm.memory[2] = 1; // fanout\n  wasm.memory[3] = 1; // depth\n\n  if (salt) wasm.memory.set(salt, 32);\n  if (personal) wasm.memory.set(personal, 48);\n  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state\n  wasm.exports.blake2b_init(this.pointer, this.digestLength);\n  if (key) {\n    this.update(key);\n    wasm.memory.fill(0, head, head + key.length); // whiteout key\n    wasm.memory[this.pointer + 200] = 128;\n  }\n}\nBlake2b.prototype.update = function (input) {\n  assert(this.finalized === false, 'Hash instance finalized');\n  assert(input instanceof Uint8Array, 'input must be Uint8Array or Buffer');\n  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);\n  wasm.memory.set(input, head);\n  wasm.exports.blake2b_update(this.pointer, head, head + input.length);\n  return this;\n};\nBlake2b.prototype.digest = function (enc) {\n  assert(this.finalized === false, 'Hash instance finalized');\n  this.finalized = true;\n  freeList.push(this.pointer);\n  wasm.exports.blake2b_final(this.pointer);\n  if (!enc || enc === 'binary') {\n    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);\n  }\n  if (enc === 'hex') {\n    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);\n  }\n  assert(enc instanceof Uint8Array && enc.length >= this.digestLength, 'input must be Uint8Array or Buffer');\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i] = wasm.memory[this.pointer + 128 + i];\n  }\n  return enc;\n};\n\n// libsodium compat\nBlake2b.prototype.final = Blake2b.prototype.digest;\nBlake2b.WASM = wasm && wasm.buffer;\nBlake2b.SUPPORTED = typeof WebAssembly !== 'undefined';\nBlake2b.ready = function (cb) {\n  if (!cb) cb = noop;\n  if (!wasm) return cb(new Error('WebAssembly not supported'));\n\n  // backwards compat, can be removed in a new major\n  const p = new Promise(function (reject, resolve) {\n    wasm.onload(function (err) {\n      if (err) resolve();else reject();\n      cb(err);\n    });\n  });\n  return p;\n};\nBlake2b.prototype.ready = Blake2b.ready;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nfunction hexSlice(buf, start, len) {\n  let str = '';\n  for (let i = 0; i < len; i++) str += toHex(buf[start + i]);\n  return str;\n}\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}","map":{"version":3,"names":["assert","require","wasm","head","freeList","module","exports","Blake2b","BYTES_MIN","BYTES_MAX","BYTES","KEYBYTES_MIN","KEYBYTES_MAX","KEYBYTES","SALTBYTES","PERSONALBYTES","digestLength","key","salt","personal","noAssert","Error","Uint8Array","length","push","finalized","pointer","pop","memory","fill","set","realloc","blake2b_init","update","prototype","input","blake2b_update","digest","enc","blake2b_final","slice","hexSlice","i","final","WASM","buffer","SUPPORTED","WebAssembly","ready","cb","noop","p","Promise","reject","resolve","onload","err","buf","start","len","str","toHex","n","toString"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/blake2b-wasm/index.js"],"sourcesContent":["const assert = require('nanoassert');\nconst wasm = require('./blake2b')();\n\nlet head = 64;\nconst freeList = [];\n\nmodule.exports = Blake2b;\nconst BYTES_MIN = (module.exports.BYTES_MIN = 16);\nconst BYTES_MAX = (module.exports.BYTES_MAX = 64);\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst BYTES = (module.exports.BYTES = 32);\nconst KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16);\nconst KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64);\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst KEYBYTES = (module.exports.KEYBYTES = 32);\nconst SALTBYTES = (module.exports.SALTBYTES = 16);\nconst PERSONALBYTES = (module.exports.PERSONALBYTES = 16);\n\nfunction Blake2b(digestLength, key, salt, personal, noAssert) {\n  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);\n  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');\n  if (!digestLength) digestLength = 32;\n\n  if (noAssert !== true) {\n    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);\n    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);\n    if (key != null) {\n      assert(key instanceof Uint8Array, 'key must be Uint8Array or Buffer');\n      assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);\n      assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);\n    }\n    if (salt != null) {\n      assert(salt instanceof Uint8Array, 'salt must be Uint8Array or Buffer');\n      assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);\n    }\n    if (personal != null) {\n      assert(personal instanceof Uint8Array, 'personal must be Uint8Array or Buffer');\n      assert(\n        personal.length === PERSONALBYTES,\n        'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length\n      );\n    }\n  }\n\n  if (!freeList.length) {\n    freeList.push(head);\n    head += 216;\n  }\n\n  this.digestLength = digestLength;\n  this.finalized = false;\n  this.pointer = freeList.pop();\n\n  wasm.memory.fill(0, 0, 64);\n  wasm.memory[0] = this.digestLength;\n  wasm.memory[1] = key ? key.length : 0;\n  wasm.memory[2] = 1; // fanout\n  wasm.memory[3] = 1; // depth\n\n  if (salt) wasm.memory.set(salt, 32);\n  if (personal) wasm.memory.set(personal, 48);\n\n  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state\n  wasm.exports.blake2b_init(this.pointer, this.digestLength);\n\n  if (key) {\n    this.update(key);\n    wasm.memory.fill(0, head, head + key.length); // whiteout key\n    wasm.memory[this.pointer + 200] = 128;\n  }\n}\n\nBlake2b.prototype.update = function (input) {\n  assert(this.finalized === false, 'Hash instance finalized');\n  assert(input instanceof Uint8Array, 'input must be Uint8Array or Buffer');\n\n  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);\n  wasm.memory.set(input, head);\n  wasm.exports.blake2b_update(this.pointer, head, head + input.length);\n  return this;\n};\n\nBlake2b.prototype.digest = function (enc) {\n  assert(this.finalized === false, 'Hash instance finalized');\n  this.finalized = true;\n\n  freeList.push(this.pointer);\n  wasm.exports.blake2b_final(this.pointer);\n\n  if (!enc || enc === 'binary') {\n    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);\n  }\n\n  if (enc === 'hex') {\n    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);\n  }\n\n  assert(enc instanceof Uint8Array && enc.length >= this.digestLength, 'input must be Uint8Array or Buffer');\n  for (let i = 0; i < this.digestLength; i++) {\n    enc[i] = wasm.memory[this.pointer + 128 + i];\n  }\n\n  return enc;\n};\n\n// libsodium compat\nBlake2b.prototype.final = Blake2b.prototype.digest;\n\nBlake2b.WASM = wasm && wasm.buffer;\nBlake2b.SUPPORTED = typeof WebAssembly !== 'undefined';\n\nBlake2b.ready = function (cb) {\n  if (!cb) cb = noop;\n  if (!wasm) return cb(new Error('WebAssembly not supported'));\n\n  // backwards compat, can be removed in a new major\n  const p = new Promise(function (reject, resolve) {\n    wasm.onload(function (err) {\n      if (err) resolve();\n      else reject();\n      cb(err);\n    });\n  });\n\n  return p;\n};\n\nBlake2b.prototype.ready = Blake2b.ready;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nfunction hexSlice(buf, start, len) {\n  let str = '';\n  for (let i = 0; i < len; i++) str += toHex(buf[start + i]);\n  return str;\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}