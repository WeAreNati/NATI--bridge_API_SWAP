{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar bcrypto = require('./crypto');\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar bufferutils = require('./bufferutils');\nvar varuint = require('varuint-bitcoin');\nvar networks = require('./networks');\nvar coins = require('./coins');\nvar Transaction = require('./transaction');\nfunction Block(network) {\n  typeforce(types.maybe(types.Network), network);\n  if (coins.isZcash(network)) {\n    /* istanbul ignore next */\n    throw new Error('unsupported network');\n  }\n  network = network || networks.bitcoin;\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n  this.network = network;\n  if (coins.isZcashCompatible(network)) {\n    this.finalSaplingRoot = null;\n    this.solutionSize = 0;\n    this.solution = null;\n  }\n}\nBlock.HEADER_BYTE_SIZE = 80;\nBlock.ZCASH_HEADER_BYTE_SIZE = 140;\nBlock.prototype.byteLength = function (headersOnly) {\n  if (coins.isZcashCompatible(this.network)) {\n    var solutionSizeNum = this.solutionSize || 0;\n    var headerSizeNum = Block.ZCASH_HEADER_BYTE_SIZE + varuint.encodingLength(solutionSizeNum) + solutionSizeNum;\n    if (headersOnly) {\n      return headerSizeNum;\n    }\n    return headerSizeNum + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n      return a + x.byteLength();\n    }, 0);\n  }\n  if (headersOnly || !this.transactions) return Block.HEADER_BYTE_SIZE;\n  return Block.HEADER_BYTE_SIZE + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\nBlock.fromBuffer = function (buffer, network) {\n  network = network || networks.bitcoin;\n  var bufferReader = new bufferutils.BufferReader(buffer);\n  var block = new Block(network);\n  var headerLength = block.byteLength(true);\n  if (buffer.length < headerLength) throw new Error('Buffer too small (< ' + headerLength + ' bytes)');\n  block.version = bufferReader.readInt32();\n  block.prevHash = bufferReader.readSlice(32);\n  block.merkleRoot = bufferReader.readSlice(32);\n  if (coins.isZcashCompatible(network)) {\n    block.finalSaplingRoot = bufferReader.readSlice(32);\n  }\n  block.timestamp = bufferReader.readUInt32();\n  block.bits = bufferReader.readUInt32();\n  if (coins.isZcashCompatible(network)) {\n    block.nonce = bufferReader.readSlice(32);\n    block.solutionSize = bufferReader.readVarInt();\n    block.solution = bufferReader.readSlice(block.solutionSize);\n  } else {\n    // Not sure sure why the nonce is read as UInt 32 and not as a slice\n    block.nonce = bufferReader.readUInt32();\n  }\n  if (bufferReader.buffer.length === headerLength) return block;\n  function readTransaction() {\n    var tx = Transaction.fromBuffer(buffer.slice(bufferReader.offset), network, true);\n    bufferReader.offset += tx.byteLength();\n    return tx;\n  }\n  var nTransactions = bufferReader.readVarInt();\n  block.transactions = [];\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction();\n    block.transactions.push(tx);\n  }\n  return block;\n};\nBlock.fromHex = function (hex, network) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0); // epoch\n  date.setUTCSeconds(this.timestamp);\n  return date;\n};\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  var bufferWriter = new bufferutils.BufferWriter(buffer);\n  bufferWriter.writeInt32(this.version);\n  bufferWriter.writeSlice(this.prevHash);\n  bufferWriter.writeSlice(this.merkleRoot);\n  if (coins.isZcashCompatible(this.network)) {\n    bufferWriter.writeSlice(this.finalSaplingRoot);\n  }\n  bufferWriter.writeUInt32(this.timestamp);\n  bufferWriter.writeUInt32(this.bits);\n  if (coins.isZcashCompatible(this.network)) {\n    bufferWriter.writeSlice(this.nonce);\n    // TODO: use writeVarInt\n    varuint.encode(this.solutionSize, bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    bufferWriter.writeSlice(this.solution);\n  } else {\n    // Not sure sure why the nonce is interpreted as UInt 32 and not a slice in bitcoin\n    bufferWriter.writeUInt32(this.nonce);\n  }\n  if (headersOnly || !this.transactions) return buffer;\n  // TODO: use writeVarInt\n  varuint.encode(this.transactions.length, bufferWriter.buffer, bufferWriter.offset);\n  bufferWriter.offset += varuint.encode.bytes;\n  // TODO: use writeVarInt\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n    tx.toBuffer(bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += txSize;\n  });\n  return buffer;\n};\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3;\n  var mantissa = bits & 0x007fffff;\n  var target = Buffer.alloc(32, 0);\n  if (exponent < 0) {\n    // If it is negative, we will overflow the target buffer so we have to slice the mantissa to fit\n    mantissa = mantissa >> 8 * Math.abs(exponent);\n    target.writeUInt32BE(mantissa, 28);\n  } else if (exponent > 28) {\n    // If it is greater than 28, we need to shift the mantissa since the offset cannot be greater than 32 - 4\n    // (safe-buffer restriction)\n    mantissa <<= 8 * (exponent - 28);\n    target.writeUInt32BE(mantissa, 0);\n  } else {\n    target.writeUInt32BE(mantissa, 28 - exponent);\n  }\n  return target;\n};\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse();\n  var target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\nmodule.exports = Block;","map":{"version":3,"names":["Buffer","require","bcrypto","fastMerkleRoot","typeforce","types","bufferutils","varuint","networks","coins","Transaction","Block","network","maybe","Network","isZcash","Error","bitcoin","version","prevHash","merkleRoot","timestamp","bits","nonce","isZcashCompatible","finalSaplingRoot","solutionSize","solution","HEADER_BYTE_SIZE","ZCASH_HEADER_BYTE_SIZE","prototype","byteLength","headersOnly","solutionSizeNum","headerSizeNum","encodingLength","transactions","length","reduce","a","x","fromBuffer","buffer","bufferReader","BufferReader","block","headerLength","readInt32","readSlice","readUInt32","readVarInt","readTransaction","tx","slice","offset","nTransactions","i","push","fromHex","hex","from","getHash","hash256","toBuffer","getId","reverse","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","encode","bytes","forEach","txSize","toHex","calculateTarget","exponent","mantissa","target","alloc","Math","abs","writeUInt32BE","calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","hash","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/block.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar bcrypto = require('./crypto');\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar bufferutils = require('./bufferutils');\nvar varuint = require('varuint-bitcoin');\nvar networks = require('./networks');\nvar coins = require('./coins');\nvar Transaction = require('./transaction');\nfunction Block(network) {\n    typeforce(types.maybe(types.Network), network);\n    if (coins.isZcash(network)) {\n        /* istanbul ignore next */\n        throw new Error('unsupported network');\n    }\n    network = network || networks.bitcoin;\n    this.version = 1;\n    this.prevHash = null;\n    this.merkleRoot = null;\n    this.timestamp = 0;\n    this.bits = 0;\n    this.nonce = 0;\n    this.network = network;\n    if (coins.isZcashCompatible(network)) {\n        this.finalSaplingRoot = null;\n        this.solutionSize = 0;\n        this.solution = null;\n    }\n}\nBlock.HEADER_BYTE_SIZE = 80;\nBlock.ZCASH_HEADER_BYTE_SIZE = 140;\nBlock.prototype.byteLength = function (headersOnly) {\n    if (coins.isZcashCompatible(this.network)) {\n        var solutionSizeNum = this.solutionSize || 0;\n        var headerSizeNum = Block.ZCASH_HEADER_BYTE_SIZE + varuint.encodingLength(solutionSizeNum) + solutionSizeNum;\n        if (headersOnly) {\n            return headerSizeNum;\n        }\n        return headerSizeNum +\n            varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n            return a + x.byteLength();\n        }, 0);\n    }\n    if (headersOnly || !this.transactions)\n        return Block.HEADER_BYTE_SIZE;\n    return Block.HEADER_BYTE_SIZE +\n        varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n        return a + x.byteLength();\n    }, 0);\n};\nBlock.fromBuffer = function (buffer, network) {\n    network = network || networks.bitcoin;\n    var bufferReader = new bufferutils.BufferReader(buffer);\n    var block = new Block(network);\n    var headerLength = block.byteLength(true);\n    if (buffer.length < headerLength)\n        throw new Error('Buffer too small (< ' + headerLength + ' bytes)');\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    if (coins.isZcashCompatible(network)) {\n        block.finalSaplingRoot = bufferReader.readSlice(32);\n    }\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    if (coins.isZcashCompatible(network)) {\n        block.nonce = bufferReader.readSlice(32);\n        block.solutionSize = bufferReader.readVarInt();\n        block.solution = bufferReader.readSlice(block.solutionSize);\n    }\n    else {\n        // Not sure sure why the nonce is read as UInt 32 and not as a slice\n        block.nonce = bufferReader.readUInt32();\n    }\n    if (bufferReader.buffer.length === headerLength)\n        return block;\n    function readTransaction() {\n        var tx = Transaction.fromBuffer(buffer.slice(bufferReader.offset), network, true);\n        bufferReader.offset += tx.byteLength();\n        return tx;\n    }\n    var nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (var i = 0; i < nTransactions; ++i) {\n        var tx = readTransaction();\n        block.transactions.push(tx);\n    }\n    return block;\n};\nBlock.fromHex = function (hex, network) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\nBlock.prototype.getHash = function () {\n    return bcrypto.hash256(this.toBuffer(true));\n};\nBlock.prototype.getId = function () {\n    return this.getHash().reverse().toString('hex');\n};\nBlock.prototype.getUTCDate = function () {\n    var date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n};\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n    var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    var bufferWriter = new bufferutils.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    if (coins.isZcashCompatible(this.network)) {\n        bufferWriter.writeSlice(this.finalSaplingRoot);\n    }\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    if (coins.isZcashCompatible(this.network)) {\n        bufferWriter.writeSlice(this.nonce);\n        // TODO: use writeVarInt\n        varuint.encode(this.solutionSize, bufferWriter.buffer, bufferWriter.offset);\n        bufferWriter.offset += varuint.encode.bytes;\n        bufferWriter.writeSlice(this.solution);\n    }\n    else {\n        // Not sure sure why the nonce is interpreted as UInt 32 and not a slice in bitcoin\n        bufferWriter.writeUInt32(this.nonce);\n    }\n    if (headersOnly || !this.transactions)\n        return buffer;\n    // TODO: use writeVarInt\n    varuint.encode(this.transactions.length, bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    // TODO: use writeVarInt\n    this.transactions.forEach(function (tx) {\n        var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n        tx.toBuffer(bufferWriter.buffer, bufferWriter.offset);\n        bufferWriter.offset += txSize;\n    });\n    return buffer;\n};\nBlock.prototype.toHex = function (headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n};\nBlock.calculateTarget = function (bits) {\n    var exponent = ((bits & 0xff000000) >> 24) - 3;\n    var mantissa = bits & 0x007fffff;\n    var target = Buffer.alloc(32, 0);\n    if (exponent < 0) {\n        // If it is negative, we will overflow the target buffer so we have to slice the mantissa to fit\n        mantissa = mantissa >> (8 * Math.abs(exponent));\n        target.writeUInt32BE(mantissa, 28);\n    }\n    else if (exponent > 28) {\n        // If it is greater than 28, we need to shift the mantissa since the offset cannot be greater than 32 - 4\n        // (safe-buffer restriction)\n        mantissa <<= 8 * (exponent - 28);\n        target.writeUInt32BE(mantissa, 0);\n    }\n    else {\n        target.writeUInt32BE(mantissa, 28 - exponent);\n    }\n    return target;\n};\nBlock.calculateMerkleRoot = function (transactions) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0)\n        throw TypeError('Cannot compute merkle root for zero transactions');\n    var hashes = transactions.map(function (transaction) {\n        return transaction.getHash();\n    });\n    return fastMerkleRoot(hashes, bcrypto.hash256);\n};\nBlock.prototype.checkMerkleRoot = function () {\n    if (!this.transactions)\n        return false;\n    var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\nBlock.prototype.checkProofOfWork = function () {\n    var hash = this.getHash().reverse();\n    var target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n};\nmodule.exports = Block;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}