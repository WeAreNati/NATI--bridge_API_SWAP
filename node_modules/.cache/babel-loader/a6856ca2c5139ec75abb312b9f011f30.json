{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar varuint = require('varuint-bitcoin');\nvar bufferutils = require('./bufferutils');\nvar fromBase58Check = require('./address').fromBase58Check;\nvar sha256 = require('./crypto').sha256;\nvar createHash = require('create-hash');\nvar ECSignature = require('./ecsignature');\nvar ECPair = require('./ecpair');\nvar VERUS_DATA_SIGNATURE_PREFIX_STRING = 'Verus signed data:\\n';\nvar bufferWriter = new bufferutils.BufferWriter(Buffer.alloc(VERUS_DATA_SIGNATURE_PREFIX_STRING.length + 1));\nbufferWriter.writeVarSlice(Buffer.from('Verus signed data:\\n', 'utf-8'));\nvar VERUS_DATA_SIGNATURE_PREFIX = bufferWriter.buffer;\nvar HASH_INVALID = 0; // eslint-disable-line\nvar HASH_BLAKE2BMMR = 1; // eslint-disable-line\nvar HASH_BLAKE2BMMR2 = 2; // eslint-disable-line\nvar HASH_KECCAK = 3; // eslint-disable-line\nvar HASH_SHA256D = 4; // eslint-disable-line\nvar HASH_SHA256 = 5;\nvar HASH_LASTTYPE = 5; // eslint-disable-line\nvar IdentitySignature = /** @class */function () {\n  function IdentitySignature(network, version, hashType, blockHeight, signatures, chainId, iAddress) {\n    if (version === void 0) {\n      version = 2;\n    }\n    if (hashType === void 0) {\n      hashType = HASH_SHA256;\n    }\n    if (blockHeight === void 0) {\n      blockHeight = 0;\n    }\n    this.version = version;\n    this.hashType = hashType;\n    this.blockHeight = blockHeight;\n    this.chainId = chainId == null ? null : fromBase58Check(chainId).hash;\n    this.identity = iAddress == null ? null : fromBase58Check(iAddress).hash;\n    this.network = network;\n    this.assertSupported();\n    if (signatures != null) {\n      this.signatures = signatures;\n    } else {\n      this.signatures = [];\n    }\n  }\n  IdentitySignature.prototype.assertSupported = function () {\n    if (this.version !== 1 && this.version !== 2) throw new Error('Unsupported version');\n    if (this.version === 2 && this.hashType !== HASH_SHA256) throw new Error('Unsupported hashtype');\n  };\n  IdentitySignature.prototype.hashMessage = function (msg) {\n    var rawMsgBuffer = Buffer.from(msg.toLowerCase(), 'utf-8');\n    var msgBufferWriter = new bufferutils.BufferWriter(Buffer.alloc(varuint.encodingLength(rawMsgBuffer.length) + rawMsgBuffer.length));\n    msgBufferWriter.writeVarSlice(rawMsgBuffer);\n    var _msgHash = sha256(msgBufferWriter.buffer);\n    var heightBufferWriter = new bufferutils.BufferWriter(Buffer.alloc(4));\n    heightBufferWriter.writeUInt32(this.blockHeight);\n    return createHash('sha256').update(VERUS_DATA_SIGNATURE_PREFIX).update(this.chainId).update(heightBufferWriter.buffer).update(this.identity).update(_msgHash).digest();\n  };\n  IdentitySignature.prototype.signMessageOffline = function (msg, keyPair) {\n    return this.signHashOffline(this.hashMessage(msg), keyPair);\n  };\n  IdentitySignature.prototype.verifyMessageOffline = function (msg, signingAddress) {\n    return this.verifyHashOffline(this.hashMessage(msg), signingAddress);\n  };\n  IdentitySignature.prototype.signHashOffline = function (buffer, keyPair) {\n    this.assertSupported();\n    var signature = keyPair.sign(buffer);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    var signingAddress = keyPair.getAddress();\n    var recid;\n    var compactSig;\n    // Try all possible recovery ids until one that can recover the\n    // correct pubkey is found. This is not the most efficient way to do this.\n    for (recid = 0; recid < 4; recid++) {\n      compactSig = signature.toCompact(recid, true);\n      var recoveredKeyPair = ECPair.recoverFromSignature(buffer, compactSig, this.network);\n      if (recoveredKeyPair.getAddress() === signingAddress) {\n        this.signatures.push(compactSig);\n        return compactSig;\n      }\n    }\n    throw new Error('Failed to generate signature with valid recovery id');\n  };\n  // In this case keyPair refers to the ECPair containing at minimum\n  // a pubkey. This function returns an array of booleans indicating which\n  // signatures passed and failed\n  IdentitySignature.prototype.verifyHashOffline = function (hash, signingAddress) {\n    this.assertSupported();\n    if (this.signatures.length === 0) throw new Error('No signatures to verify');\n    var results = [];\n    for (var i = 0; i < this.signatures.length; i++) {\n      try {\n        var sig = ECSignature.parseCompact(this.signatures[i]);\n        var pubKeyPair = ECPair.recoverFromSignature(hash, sig.signature.toCompact(sig.i, true), this.network);\n        if (pubKeyPair.getAddress() === signingAddress) {\n          var verification = pubKeyPair.verify(hash, sig.signature);\n          results.push(verification);\n        } else {\n          results.push(false);\n        }\n      } catch (e) {\n        console.log(e);\n        results.push(false);\n      }\n    }\n    return results;\n  };\n  IdentitySignature.prototype.fromBuffer = function (buffer, initialOffset, chainId, iAddress) {\n    var bufferReader = new bufferutils.BufferReader(buffer, initialOffset || 0);\n    this.version = bufferReader.readUInt8();\n    if (this.version === 2) this.hashType = bufferReader.readUInt8();\n    this.assertSupported();\n    this.blockHeight = bufferReader.readUInt32();\n    var numSigs = bufferReader.readUInt8();\n    this.chainId = chainId == null ? null : fromBase58Check(chainId).hash;\n    this.identity = iAddress == null ? null : fromBase58Check(iAddress).hash;\n    for (var i = 0; i < numSigs; i++) {\n      this.signatures.push(bufferReader.readVarSlice());\n    }\n    return bufferReader.offset;\n  };\n  IdentitySignature.prototype.__byteLength = function () {\n    var totalSigLength = 0;\n    this.signatures.forEach(function (sig) {\n      totalSigLength += sig.length;\n    });\n    return (this.version === 2 ? 7 : 6) + varuint.encodingLength(this.signatures.length) + totalSigLength;\n  };\n  IdentitySignature.prototype.toBuffer = function (buffer, initialOffset) {\n    this.assertSupported();\n    var noBuffer = !buffer;\n    if (noBuffer) buffer = Buffer.allocUnsafe(this.__byteLength());\n    var bufferWriter = new bufferutils.BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeUInt8(this.version);\n    if (this.version === 2) bufferWriter.writeUInt8(this.hashType);\n    bufferWriter.writeUInt32(this.blockHeight);\n    bufferWriter.writeUInt8(this.signatures.length); // num signatures\n    for (var _i = 0, _a = this.signatures; _i < _a.length; _i++) {\n      var sig = _a[_i];\n      bufferWriter.writeVarSlice(sig);\n    }\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined) {\n      return noBuffer ? bufferWriter.buffer.slice(initialOffset, bufferWriter.offset) : bufferWriter.offset;\n    }\n    // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n    return noBuffer ? bufferWriter.buffer.slice(0, bufferWriter.offset) : bufferWriter.offset;\n  };\n  return IdentitySignature;\n}();\nmodule.exports = IdentitySignature;","map":{"version":3,"names":["Buffer","require","varuint","bufferutils","fromBase58Check","sha256","createHash","ECSignature","ECPair","VERUS_DATA_SIGNATURE_PREFIX_STRING","bufferWriter","BufferWriter","alloc","length","writeVarSlice","from","VERUS_DATA_SIGNATURE_PREFIX","buffer","HASH_INVALID","HASH_BLAKE2BMMR","HASH_BLAKE2BMMR2","HASH_KECCAK","HASH_SHA256D","HASH_SHA256","HASH_LASTTYPE","IdentitySignature","network","version","hashType","blockHeight","signatures","chainId","iAddress","hash","identity","assertSupported","prototype","Error","hashMessage","msg","rawMsgBuffer","toLowerCase","msgBufferWriter","encodingLength","_msgHash","heightBufferWriter","writeUInt32","update","digest","signMessageOffline","keyPair","signHashOffline","verifyMessageOffline","signingAddress","verifyHashOffline","signature","sign","isBuffer","fromRSBuffer","getAddress","recid","compactSig","toCompact","recoveredKeyPair","recoverFromSignature","push","results","i","sig","parseCompact","pubKeyPair","verification","verify","e","console","log","fromBuffer","initialOffset","bufferReader","BufferReader","readUInt8","readUInt32","numSigs","readVarSlice","offset","__byteLength","totalSigLength","forEach","toBuffer","noBuffer","allocUnsafe","writeUInt8","_i","_a","undefined","slice","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/identity_signature.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar varuint = require('varuint-bitcoin');\nvar bufferutils = require('./bufferutils');\nvar fromBase58Check = require('./address').fromBase58Check;\nvar sha256 = require('./crypto').sha256;\nvar createHash = require('create-hash');\nvar ECSignature = require('./ecsignature');\nvar ECPair = require('./ecpair');\nvar VERUS_DATA_SIGNATURE_PREFIX_STRING = 'Verus signed data:\\n';\nvar bufferWriter = new bufferutils.BufferWriter(Buffer.alloc(VERUS_DATA_SIGNATURE_PREFIX_STRING.length + 1));\nbufferWriter.writeVarSlice(Buffer.from('Verus signed data:\\n', 'utf-8'));\nvar VERUS_DATA_SIGNATURE_PREFIX = bufferWriter.buffer;\nvar HASH_INVALID = 0; // eslint-disable-line\nvar HASH_BLAKE2BMMR = 1; // eslint-disable-line\nvar HASH_BLAKE2BMMR2 = 2; // eslint-disable-line\nvar HASH_KECCAK = 3; // eslint-disable-line\nvar HASH_SHA256D = 4; // eslint-disable-line\nvar HASH_SHA256 = 5;\nvar HASH_LASTTYPE = 5; // eslint-disable-line\nvar IdentitySignature = /** @class */ (function () {\n    function IdentitySignature(network, version, hashType, blockHeight, signatures, chainId, iAddress) {\n        if (version === void 0) { version = 2; }\n        if (hashType === void 0) { hashType = HASH_SHA256; }\n        if (blockHeight === void 0) { blockHeight = 0; }\n        this.version = version;\n        this.hashType = hashType;\n        this.blockHeight = blockHeight;\n        this.chainId = chainId == null ? null : fromBase58Check(chainId).hash;\n        this.identity = iAddress == null ? null : fromBase58Check(iAddress).hash;\n        this.network = network;\n        this.assertSupported();\n        if (signatures != null) {\n            this.signatures = signatures;\n        }\n        else {\n            this.signatures = [];\n        }\n    }\n    IdentitySignature.prototype.assertSupported = function () {\n        if (this.version !== 1 && this.version !== 2)\n            throw new Error('Unsupported version');\n        if (this.version === 2 && this.hashType !== HASH_SHA256)\n            throw new Error('Unsupported hashtype');\n    };\n    IdentitySignature.prototype.hashMessage = function (msg) {\n        var rawMsgBuffer = Buffer.from(msg.toLowerCase(), 'utf-8');\n        var msgBufferWriter = new bufferutils.BufferWriter(Buffer.alloc(varuint.encodingLength(rawMsgBuffer.length) + rawMsgBuffer.length));\n        msgBufferWriter.writeVarSlice(rawMsgBuffer);\n        var _msgHash = sha256(msgBufferWriter.buffer);\n        var heightBufferWriter = new bufferutils.BufferWriter(Buffer.alloc(4));\n        heightBufferWriter.writeUInt32(this.blockHeight);\n        return createHash('sha256')\n            .update(VERUS_DATA_SIGNATURE_PREFIX)\n            .update(this.chainId)\n            .update(heightBufferWriter.buffer)\n            .update(this.identity)\n            .update(_msgHash)\n            .digest();\n    };\n    IdentitySignature.prototype.signMessageOffline = function (msg, keyPair) {\n        return this.signHashOffline(this.hashMessage(msg), keyPair);\n    };\n    IdentitySignature.prototype.verifyMessageOffline = function (msg, signingAddress) {\n        return this.verifyHashOffline(this.hashMessage(msg), signingAddress);\n    };\n    IdentitySignature.prototype.signHashOffline = function (buffer, keyPair) {\n        this.assertSupported();\n        var signature = keyPair.sign(buffer);\n        if (Buffer.isBuffer(signature))\n            signature = ECSignature.fromRSBuffer(signature);\n        var signingAddress = keyPair.getAddress();\n        var recid;\n        var compactSig;\n        // Try all possible recovery ids until one that can recover the\n        // correct pubkey is found. This is not the most efficient way to do this.\n        for (recid = 0; recid < 4; recid++) {\n            compactSig = signature.toCompact(recid, true);\n            var recoveredKeyPair = ECPair.recoverFromSignature(buffer, compactSig, this.network);\n            if (recoveredKeyPair.getAddress() === signingAddress) {\n                this.signatures.push(compactSig);\n                return compactSig;\n            }\n        }\n        throw new Error('Failed to generate signature with valid recovery id');\n    };\n    // In this case keyPair refers to the ECPair containing at minimum\n    // a pubkey. This function returns an array of booleans indicating which\n    // signatures passed and failed\n    IdentitySignature.prototype.verifyHashOffline = function (hash, signingAddress) {\n        this.assertSupported();\n        if (this.signatures.length === 0)\n            throw new Error('No signatures to verify');\n        var results = [];\n        for (var i = 0; i < this.signatures.length; i++) {\n            try {\n                var sig = ECSignature.parseCompact(this.signatures[i]);\n                var pubKeyPair = ECPair.recoverFromSignature(hash, sig.signature.toCompact(sig.i, true), this.network);\n                if (pubKeyPair.getAddress() === signingAddress) {\n                    var verification = pubKeyPair.verify(hash, sig.signature);\n                    results.push(verification);\n                }\n                else {\n                    results.push(false);\n                }\n            }\n            catch (e) {\n                console.log(e);\n                results.push(false);\n            }\n        }\n        return results;\n    };\n    IdentitySignature.prototype.fromBuffer = function (buffer, initialOffset, chainId, iAddress) {\n        var bufferReader = new bufferutils.BufferReader(buffer, initialOffset || 0);\n        this.version = bufferReader.readUInt8();\n        if (this.version === 2)\n            this.hashType = bufferReader.readUInt8();\n        this.assertSupported();\n        this.blockHeight = bufferReader.readUInt32();\n        var numSigs = bufferReader.readUInt8();\n        this.chainId = chainId == null ? null : fromBase58Check(chainId).hash;\n        this.identity = iAddress == null ? null : fromBase58Check(iAddress).hash;\n        for (var i = 0; i < numSigs; i++) {\n            this.signatures.push(bufferReader.readVarSlice());\n        }\n        return bufferReader.offset;\n    };\n    IdentitySignature.prototype.__byteLength = function () {\n        var totalSigLength = 0;\n        this.signatures.forEach(function (sig) {\n            totalSigLength += sig.length;\n        });\n        return ((this.version === 2 ? 7 : 6) +\n            varuint.encodingLength(this.signatures.length) +\n            totalSigLength);\n    };\n    IdentitySignature.prototype.toBuffer = function (buffer, initialOffset) {\n        this.assertSupported();\n        var noBuffer = !buffer;\n        if (noBuffer)\n            buffer = Buffer.allocUnsafe(this.__byteLength());\n        var bufferWriter = new bufferutils.BufferWriter(buffer, initialOffset || 0);\n        bufferWriter.writeUInt8(this.version);\n        if (this.version === 2)\n            bufferWriter.writeUInt8(this.hashType);\n        bufferWriter.writeUInt32(this.blockHeight);\n        bufferWriter.writeUInt8(this.signatures.length); // num signatures\n        for (var _i = 0, _a = this.signatures; _i < _a.length; _i++) {\n            var sig = _a[_i];\n            bufferWriter.writeVarSlice(sig);\n        }\n        // avoid slicing unless necessary\n        if (initialOffset !== undefined) {\n            return noBuffer\n                ? bufferWriter.buffer.slice(initialOffset, bufferWriter.offset)\n                : bufferWriter.offset;\n        }\n        // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n        return noBuffer ? bufferWriter.buffer.slice(0, bufferWriter.offset) : bufferWriter.offset;\n    };\n    return IdentitySignature;\n}());\nmodule.exports = IdentitySignature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}