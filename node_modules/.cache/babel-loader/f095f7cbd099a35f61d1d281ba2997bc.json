{"ast":null,"code":"\"use strict\";\n\n// The MIT License (MIT)\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = void 0;\nconst varuint_1 = require(\"./varuint\");\nconst varint_1 = require(\"./varint\");\nconst bn_js_1 = require(\"bn.js\");\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== \"number\") throw new Error(\"cannot write a non-number as a number\");\n  if (value < 0) throw new Error(\"specified a negative value for writing an unsigned value\");\n  if (value > max) throw new Error(\"RangeError: value out of range\");\n  if (Math.floor(value) !== value) throw new Error(\"value has a fractional component\");\n}\nconst readUInt64LE = (buffer, offset) => {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n};\nexports.readUInt64LE = readUInt64LE;\nconst writeUInt64LE = (buffer, value, offset) => {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n};\nexports.writeUInt64LE = writeUInt64LE;\nconst reverseBuffer = buffer => {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n};\nexports.reverseBuffer = reverseBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeUInt16(i) {\n    this.offset = this.buffer.writeUInt16LE(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = (0, exports.writeUInt64LE)(this.buffer, i, this.offset);\n  }\n  writeInt64(i) {\n    const slice = i.toBuffer('le', 8);\n    this.writeSlice(slice);\n  }\n  writeCompactSize(i) {\n    const encoding = varuint_1.default.encode(i, this.buffer, this.offset);\n    this.offset += encoding.bytes;\n  }\n  writeVarInt(i) {\n    const encoding = varint_1.default.encode(i, this.buffer, this.offset);\n    this.offset += encoding.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error(\"Cannot write slice out of bounds\");\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeCompactSize(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeCompactSize(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  writeArray(array) {\n    this.writeCompactSize(array.length);\n    array.forEach(buf => this.writeSlice(buf));\n  }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = (0, exports.readUInt64LE)(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readInt64() {\n    return new bn_js_1.BN(this.readSlice(8), 16, 'le');\n  }\n  readCompactSize() {\n    const vi = varuint_1.default.decode(this.buffer, this.offset);\n    this.offset += vi.bytes;\n    return vi.decoded;\n  }\n  readVarInt() {\n    const vi = varint_1.default.decode(this.buffer, this.offset);\n    this.offset += vi.bytes;\n    return vi.decoded;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error(\"Cannot read slice out of bounds\");\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readCompactSize());\n  }\n  readVector() {\n    const count = this.readCompactSize();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n  readArray(sliceLength) {\n    const count = this.readCompactSize();\n    const array = [];\n    for (let i = 0; i < count; i++) array.push(this.readSlice(sliceLength));\n    return array;\n  }\n}\nexports.default = {\n  readUInt64LE: exports.readUInt64LE,\n  writeUInt64LE: exports.writeUInt64LE,\n  reverseBuffer: exports.reverseBuffer,\n  BufferWriter,\n  BufferReader\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","reverseBuffer","writeUInt64LE","readUInt64LE","varuint_1","require","varint_1","bn_js_1","verifuint","max","Error","Math","floor","buffer","offset","a","readUInt32LE","b","writeInt32LE","writeUInt32LE","length","j","tmp","i","BufferWriter","constructor","writeUInt8","writeUInt16","writeUInt16LE","writeInt32","writeUInt32","writeUInt64","writeInt64","slice","toBuffer","writeSlice","writeCompactSize","encoding","default","encode","bytes","writeVarInt","copy","writeVarSlice","writeVector","vector","forEach","buf","writeArray","array","BufferReader","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt64","readInt64","BN","readSlice","readCompactSize","vi","decode","decoded","readVarInt","n","readVarSlice","readVector","count","push","readArray","sliceLength"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/utils/bufferutils.js"],"sourcesContent":["\"use strict\";\n// The MIT License (MIT)\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = void 0;\nconst varuint_1 = require(\"./varuint\");\nconst varint_1 = require(\"./varint\");\nconst bn_js_1 = require(\"bn.js\");\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n    if (typeof value !== \"number\")\n        throw new Error(\"cannot write a non-number as a number\");\n    if (value < 0)\n        throw new Error(\"specified a negative value for writing an unsigned value\");\n    if (value > max)\n        throw new Error(\"RangeError: value out of range\");\n    if (Math.floor(value) !== value)\n        throw new Error(\"value has a fractional component\");\n}\nconst readUInt64LE = (buffer, offset) => {\n    const a = buffer.readUInt32LE(offset);\n    let b = buffer.readUInt32LE(offset + 4);\n    b *= 0x100000000;\n    verifuint(b + a, 0x001fffffffffffff);\n    return b + a;\n};\nexports.readUInt64LE = readUInt64LE;\nconst writeUInt64LE = (buffer, value, offset) => {\n    verifuint(value, 0x001fffffffffffff);\n    buffer.writeInt32LE(value & -1, offset);\n    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n    return offset + 8;\n};\nexports.writeUInt64LE = writeUInt64LE;\nconst reverseBuffer = (buffer) => {\n    if (buffer.length < 1)\n        return buffer;\n    let j = buffer.length - 1;\n    let tmp = 0;\n    for (let i = 0; i < buffer.length / 2; i++) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n    }\n    return buffer;\n};\nexports.reverseBuffer = reverseBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n    }\n    writeUInt8(i) {\n        this.offset = this.buffer.writeUInt8(i, this.offset);\n    }\n    writeUInt16(i) {\n        this.offset = this.buffer.writeUInt16LE(i, this.offset);\n    }\n    writeInt32(i) {\n        this.offset = this.buffer.writeInt32LE(i, this.offset);\n    }\n    writeUInt32(i) {\n        this.offset = this.buffer.writeUInt32LE(i, this.offset);\n    }\n    writeUInt64(i) {\n        this.offset = (0, exports.writeUInt64LE)(this.buffer, i, this.offset);\n    }\n    writeInt64(i) {\n        const slice = i.toBuffer('le', 8);\n        this.writeSlice(slice);\n    }\n    writeCompactSize(i) {\n        const encoding = varuint_1.default.encode(i, this.buffer, this.offset);\n        this.offset += encoding.bytes;\n    }\n    writeVarInt(i) {\n        const encoding = varint_1.default.encode(i, this.buffer, this.offset);\n        this.offset += encoding.bytes;\n    }\n    writeSlice(slice) {\n        if (this.buffer.length < this.offset + slice.length) {\n            throw new Error(\"Cannot write slice out of bounds\");\n        }\n        this.offset += slice.copy(this.buffer, this.offset);\n    }\n    writeVarSlice(slice) {\n        this.writeCompactSize(slice.length);\n        this.writeSlice(slice);\n    }\n    writeVector(vector) {\n        this.writeCompactSize(vector.length);\n        vector.forEach((buf) => this.writeVarSlice(buf));\n    }\n    writeArray(array) {\n        this.writeCompactSize(array.length);\n        array.forEach((buf) => this.writeSlice(buf));\n    }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n    }\n    readUInt8() {\n        const result = this.buffer.readUInt8(this.offset);\n        this.offset++;\n        return result;\n    }\n    readInt32() {\n        const result = this.buffer.readInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt32() {\n        const result = this.buffer.readUInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt64() {\n        const result = (0, exports.readUInt64LE)(this.buffer, this.offset);\n        this.offset += 8;\n        return result;\n    }\n    readInt64() {\n        return new bn_js_1.BN(this.readSlice(8), 16, 'le');\n    }\n    readCompactSize() {\n        const vi = varuint_1.default.decode(this.buffer, this.offset);\n        this.offset += vi.bytes;\n        return vi.decoded;\n    }\n    readVarInt() {\n        const vi = varint_1.default.decode(this.buffer, this.offset);\n        this.offset += vi.bytes;\n        return vi.decoded;\n    }\n    readSlice(n) {\n        if (this.buffer.length < this.offset + n) {\n            throw new Error(\"Cannot read slice out of bounds\");\n        }\n        const result = this.buffer.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return result;\n    }\n    readVarSlice() {\n        return this.readSlice(this.readCompactSize());\n    }\n    readVector() {\n        const count = this.readCompactSize();\n        const vector = [];\n        for (let i = 0; i < count; i++)\n            vector.push(this.readVarSlice());\n        return vector;\n    }\n    readArray(sliceLength) {\n        const count = this.readCompactSize();\n        const array = [];\n        for (let i = 0; i < count; i++)\n            array.push(this.readSlice(sliceLength));\n        return array;\n    }\n}\nexports.default = {\n    readUInt64LE: exports.readUInt64LE,\n    writeUInt64LE: exports.writeUInt64LE,\n    reverseBuffer: exports.reverseBuffer,\n    BufferWriter,\n    BufferReader,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}