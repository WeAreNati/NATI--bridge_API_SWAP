{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar bip66 = require('bip66');\nvar pushdata = require('pushdata-bitcoin');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar scriptNumber = require('./script_number');\nvar OPS = require('bitcoin-ops');\nvar REVERSE_OPS = require('bitcoin-ops/map');\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return types.Number(value) && (value === OPS.OP_0 || value >= OPS.OP_1 && value <= OPS.OP_16 || value === OPS.OP_1NEGATE);\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (Buffer.isBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  var bufferSize = chunks.reduce(function (accum, chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  var buffer = Buffer.allocUnsafe(bufferSize);\n  var offset = 0;\n  chunks.forEach(function (chunk) {\n    // data chunk\n    if (Buffer.isBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      var opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (types.Array(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  var chunks = [];\n  var i = 0;\n  while (i < buffer.length) {\n    var opcode = buffer[i];\n    // data chunk\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      var d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail? empty script\n      if (d === null) return [];\n      i += d.size;\n      // attempt to read too much data? empty script\n      if (i + d.number > buffer.length) return [];\n      var data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      var op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nfunction toASM(chunks) {\n  if (Buffer.isBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks.map(function (chunk) {\n    // data?\n    if (Buffer.isBuffer(chunk)) {\n      var op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString('hex');\n      chunk = op;\n    }\n    // opcode!\n    return REVERSE_OPS[chunk];\n  }).join(' ');\n}\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(' ').map(function (chunkStr) {\n    // opcode?\n    if (OPS[chunkStr] !== undefined) return OPS[chunkStr];\n    typeforce(types.Hex, chunkStr);\n    // data!\n    return Buffer.from(chunkStr, 'hex');\n  }));\n}\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(function (op) {\n    if (Buffer.isBuffer(op)) return op;\n    if (op === OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nfunction isCanonicalPubKey(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (buffer.length < 33) return false;\n  switch (buffer[0]) {\n    case 0x02:\n    case 0x03:\n      return buffer.length === 33;\n    case 0x04:\n      return buffer.length === 65;\n  }\n  return false;\n}\nfunction isDefinedHashType(hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nfunction isCanonicalSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nmodule.exports = {\n  compile: compile,\n  decompile: decompile,\n  fromASM: fromASM,\n  toASM: toASM,\n  toStack: toStack,\n  number: require('./script_number'),\n  isCanonicalPubKey: isCanonicalPubKey,\n  isCanonicalSignature: isCanonicalSignature,\n  isPushOnly: isPushOnly,\n  isDefinedHashType: isDefinedHashType\n};","map":{"version":3,"names":["Buffer","require","bip66","pushdata","typeforce","types","scriptNumber","OPS","REVERSE_OPS","OP_INT_BASE","OP_RESERVED","isOPInt","value","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","isPushOnly","Array","every","asMinimalOP","buffer","length","compile","chunks","isBuffer","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","decompile","i","OP_PUSHDATA4","d","decode","size","number","data","slice","op","push","toASM","map","toString","join","fromASM","asm","String","split","chunkStr","Hex","from","toStack","isCanonicalPubKey","isDefinedHashType","hashType","hashTypeMod","isCanonicalSignature","check","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/script.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar bip66 = require('bip66');\nvar pushdata = require('pushdata-bitcoin');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar scriptNumber = require('./script_number');\nvar OPS = require('bitcoin-ops');\nvar REVERSE_OPS = require('bitcoin-ops/map');\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n    return types.Number(value) &&\n        ((value === OPS.OP_0) ||\n            (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n            (value === OPS.OP_1NEGATE));\n}\nfunction isPushOnlyChunk(value) {\n    return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n    return types.Array(value) && value.every(isPushOnlyChunk);\n}\nfunction asMinimalOP(buffer) {\n    if (buffer.length === 0)\n        return OPS.OP_0;\n    if (buffer.length !== 1)\n        return;\n    if (buffer[0] >= 1 && buffer[0] <= 16)\n        return OP_INT_BASE + buffer[0];\n    if (buffer[0] === 0x81)\n        return OPS.OP_1NEGATE;\n}\nfunction compile(chunks) {\n    // TODO: remove me\n    if (Buffer.isBuffer(chunks))\n        return chunks;\n    typeforce(types.Array, chunks);\n    var bufferSize = chunks.reduce(function (accum, chunk) {\n        // data chunk\n        if (Buffer.isBuffer(chunk)) {\n            // adhere to BIP62.3, minimal push policy\n            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n                return accum + 1;\n            }\n            return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n        }\n        // opcode\n        return accum + 1;\n    }, 0.0);\n    var buffer = Buffer.allocUnsafe(bufferSize);\n    var offset = 0;\n    chunks.forEach(function (chunk) {\n        // data chunk\n        if (Buffer.isBuffer(chunk)) {\n            // adhere to BIP62.3, minimal push policy\n            var opcode = asMinimalOP(chunk);\n            if (opcode !== undefined) {\n                buffer.writeUInt8(opcode, offset);\n                offset += 1;\n                return;\n            }\n            offset += pushdata.encode(buffer, chunk.length, offset);\n            chunk.copy(buffer, offset);\n            offset += chunk.length;\n            // opcode\n        }\n        else {\n            buffer.writeUInt8(chunk, offset);\n            offset += 1;\n        }\n    });\n    if (offset !== buffer.length)\n        throw new Error('Could not decode chunks');\n    return buffer;\n}\nfunction decompile(buffer) {\n    // TODO: remove me\n    if (types.Array(buffer))\n        return buffer;\n    typeforce(types.Buffer, buffer);\n    var chunks = [];\n    var i = 0;\n    while (i < buffer.length) {\n        var opcode = buffer[i];\n        // data chunk\n        if ((opcode > OPS.OP_0) && (opcode <= OPS.OP_PUSHDATA4)) {\n            var d = pushdata.decode(buffer, i);\n            // did reading a pushDataInt fail? empty script\n            if (d === null)\n                return [];\n            i += d.size;\n            // attempt to read too much data? empty script\n            if (i + d.number > buffer.length)\n                return [];\n            var data = buffer.slice(i, i + d.number);\n            i += d.number;\n            // decompile minimally\n            var op = asMinimalOP(data);\n            if (op !== undefined) {\n                chunks.push(op);\n            }\n            else {\n                chunks.push(data);\n            }\n            // opcode\n        }\n        else {\n            chunks.push(opcode);\n            i += 1;\n        }\n    }\n    return chunks;\n}\nfunction toASM(chunks) {\n    if (Buffer.isBuffer(chunks)) {\n        chunks = decompile(chunks);\n    }\n    return chunks.map(function (chunk) {\n        // data?\n        if (Buffer.isBuffer(chunk)) {\n            var op = asMinimalOP(chunk);\n            if (op === undefined)\n                return chunk.toString('hex');\n            chunk = op;\n        }\n        // opcode!\n        return REVERSE_OPS[chunk];\n    }).join(' ');\n}\nfunction fromASM(asm) {\n    typeforce(types.String, asm);\n    return compile(asm.split(' ').map(function (chunkStr) {\n        // opcode?\n        if (OPS[chunkStr] !== undefined)\n            return OPS[chunkStr];\n        typeforce(types.Hex, chunkStr);\n        // data!\n        return Buffer.from(chunkStr, 'hex');\n    }));\n}\nfunction toStack(chunks) {\n    chunks = decompile(chunks);\n    typeforce(isPushOnly, chunks);\n    return chunks.map(function (op) {\n        if (Buffer.isBuffer(op))\n            return op;\n        if (op === OPS.OP_0)\n            return Buffer.allocUnsafe(0);\n        return scriptNumber.encode(op - OP_INT_BASE);\n    });\n}\nfunction isCanonicalPubKey(buffer) {\n    if (!Buffer.isBuffer(buffer))\n        return false;\n    if (buffer.length < 33)\n        return false;\n    switch (buffer[0]) {\n        case 0x02:\n        case 0x03:\n            return buffer.length === 33;\n        case 0x04:\n            return buffer.length === 65;\n    }\n    return false;\n}\nfunction isDefinedHashType(hashType) {\n    var hashTypeMod = hashType & ~0xc0;\n    // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n    return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nfunction isCanonicalSignature(buffer) {\n    if (!Buffer.isBuffer(buffer))\n        return false;\n    if (!isDefinedHashType(buffer[buffer.length - 1]))\n        return false;\n    return bip66.check(buffer.slice(0, -1));\n}\nmodule.exports = {\n    compile: compile,\n    decompile: decompile,\n    fromASM: fromASM,\n    toASM: toASM,\n    toStack: toStack,\n    number: require('./script_number'),\n    isCanonicalPubKey: isCanonicalPubKey,\n    isCanonicalSignature: isCanonicalSignature,\n    isPushOnly: isPushOnly,\n    isDefinedHashType: isDefinedHashType\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}