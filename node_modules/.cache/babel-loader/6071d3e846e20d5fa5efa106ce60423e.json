{"ast":null,"code":"var bscript = require('./script');\nvar EVALS = require('bitcoin-ops/evals.json');\nvar varuint = require('varuint-bitcoin');\nvar TxDestination = require('./tx_destination');\nvar bufferutils = require('./bufferutils');\nfunction varSliceSize(varSlice) {\n  var length = varSlice.length;\n  return varuint.encodingLength(length) + length;\n}\nvar OptCCParams = /** @class */function () {\n  function OptCCParams(version, evalCode, m, n, destinations, serializedObjects) {\n    if (version === void 0) {\n      version = 3;\n    }\n    if (evalCode === void 0) {\n      evalCode = 0;\n    }\n    if (m === void 0) {\n      m = 1;\n    }\n    if (n === void 0) {\n      n = 1;\n    }\n    if (destinations === void 0) {\n      destinations = [];\n    }\n    if (serializedObjects === void 0) {\n      serializedObjects = [];\n    }\n    this.version = version;\n    this.evalCode = evalCode;\n    this.m = m;\n    this.n = n;\n    this.destinations = destinations;\n    this.vData = serializedObjects;\n    // Error variable for reporting, does not get serialized\n    this.error = null;\n  }\n  OptCCParams.prototype.getParamObject = function () {\n    switch (this.evalCode) {\n      case EVALS.EVAL_NONE:\n        {\n          return null;\n        }\n      case EVALS.EVAL_STAKEGUARD:\n      case EVALS.EVAL_CURRENCY_DEFINITION:\n      case EVALS.EVAL_NOTARY_EVIDENCE:\n      case EVALS.EVAL_EARNEDNOTARIZATION:\n      case EVALS.EVAL_ACCEPTEDNOTARIZATION:\n      case EVALS.EVAL_FINALIZE_NOTARIZATION:\n      case EVALS.EVAL_CURRENCYSTATE:\n      case EVALS.EVAL_RESERVE_TRANSFER:\n      case EVALS.EVAL_RESERVE_OUTPUT:\n      case EVALS.EVAL_RESERVE_DEPOSIT:\n      case EVALS.EVAL_CROSSCHAIN_EXPORT:\n      case EVALS.EVAL_CROSSCHAIN_IMPORT:\n      case EVALS.EVAL_IDENTITY_PRIMARY:\n      case EVALS.EVAL_IDENTITY_COMMITMENT:\n      case EVALS.EVAL_IDENTITY_RESERVATION:\n      case EVALS.EVAL_FINALIZE_EXPORT:\n      case EVALS.EVAL_FEE_POOL:\n      case EVALS.EVAL_NOTARY_SIGNATURE:\n        {\n          if (this.vData.length) {\n            return this.vData[0];\n          } else {\n            return null;\n          }\n        }\n      default:\n        {\n          return null;\n        }\n    }\n  };\n  OptCCParams.prototype.isValid = function () {\n    var validEval = false;\n    switch (this.evalCode) {\n      case EVALS.EVAL_NONE:\n        {\n          validEval = true;\n          break;\n        }\n      case EVALS.EVAL_STAKEGUARD:\n      case EVALS.EVAL_CURRENCY_DEFINITION:\n      case EVALS.EVAL_NOTARY_EVIDENCE:\n      case EVALS.EVAL_EARNEDNOTARIZATION:\n      case EVALS.EVAL_ACCEPTEDNOTARIZATION:\n      case EVALS.EVAL_FINALIZE_NOTARIZATION:\n      case EVALS.EVAL_CURRENCYSTATE:\n      case EVALS.EVAL_RESERVE_TRANSFER:\n      case EVALS.EVAL_RESERVE_OUTPUT:\n      case EVALS.EVAL_RESERVE_DEPOSIT:\n      case EVALS.EVAL_CROSSCHAIN_EXPORT:\n      case EVALS.EVAL_CROSSCHAIN_IMPORT:\n      case EVALS.EVAL_IDENTITY_PRIMARY:\n      case EVALS.EVAL_IDENTITY_COMMITMENT:\n      case EVALS.EVAL_IDENTITY_RESERVATION:\n      case EVALS.EVAL_FINALIZE_EXPORT:\n      case EVALS.EVAL_FEE_POOL:\n      case EVALS.EVAL_NOTARY_SIGNATURE:\n        {\n          validEval = this.vData && this.vData.length > 0;\n        }\n    }\n    return validEval && this.version > 0 && this.version < 4 && (this.version < 3 && this.evalCode < 2 || this.evalCode <= 26 && this.m <= this.n);\n  };\n  OptCCParams.fromChunk = function (chunk) {\n    var writer = new bufferutils.BufferWriter(Buffer.alloc(varuint.encodingLength(chunk.length)), 0);\n    writer.writeVarInt(chunk.length);\n    var params = new OptCCParams();\n    params.fromBuffer(Buffer.concat([writer.buffer, chunk]));\n    return params;\n  };\n  OptCCParams.prototype.toChunk = function () {\n    return this.toBuffer(undefined, undefined, true);\n  };\n  OptCCParams.prototype.fromBuffer = function (buffer, initialOffset) {\n    if (initialOffset === void 0) {\n      initialOffset = 0;\n    }\n    // the first element in this buffer will be a script to decompile and get pushed data from\n    var offset = initialOffset;\n    function readSlice(n) {\n      offset += n;\n      return buffer.slice(offset - n, offset);\n    }\n    function readVarInt() {\n      var vi = varuint.decode(buffer, offset);\n      offset += varuint.decode.bytes;\n      return vi;\n    }\n    function readVarSlice() {\n      return readSlice(readVarInt());\n    }\n    var scriptInVector = readVarSlice();\n    var chunks = bscript.decompile(scriptInVector);\n    if (chunks[0].length !== 4) {\n      // invalid optional parameters header\n      this.version = 0;\n      this.error = new Error('invalid optional parameters header');\n      return initialOffset;\n    }\n    this.version = chunks[0].readUInt8(0);\n    this.evalCode = chunks[0].readUInt8(1);\n    this.m = chunks[0].readUInt8(2);\n    this.n = chunks[0].readUInt8(3);\n    // now, we should have n keys followed by data objects for later versions, otherwise all keys and one data object\n    if (this.version <= 0 || this.version > 3 || this.evalCode < 0 || this.evalCode > 0x1a ||\n    // this is the last valid eval code as of version 3\n    this.version < 3 && this.n < 1 || this.n > 4 || this.version < 3 && this.n >= chunks.length || this.n > chunks.length) {\n      // invalid header values\n      this.version = 0;\n      this.error = new Error('invalid header values');\n      return initialOffset;\n    }\n    // now, we have chunks left that are either destinations or data vectors\n    var limit = this.n === chunks.length ? this.n : this.n + 1;\n    this.destinations = [];\n    var loop;\n    for (loop = 1; this.version && loop < limit; loop++) {\n      var oneDest = TxDestination.fromChunk(chunks[loop]);\n      if (oneDest.isValid()) {\n        this.destinations.push(oneDest);\n      } else {\n        this.version = 0;\n        this.error = new Error('invalid destination');\n        return initialOffset;\n      }\n    }\n    for (; this.version && loop < chunks.length; loop++) {\n      this.vData.push(chunks[loop]); // is this an issue to just store as is for the data?\n    }\n    return offset;\n  };\n  OptCCParams.prototype.__byteLength = function () {\n    var chunks = [Buffer.allocUnsafe(4)];\n    chunks[0][0] = this.version;\n    chunks[0][1] = this.evalCode;\n    chunks[0][2] = this.m;\n    chunks[0][3] = this.n;\n    this.destinations.forEach(function (x) {\n      chunks.push(Buffer.allocUnsafe(x.__byteLength()));\n      x.toBuffer(chunks[chunks.length - 1]);\n    });\n    this.vData.forEach(function (x) {\n      chunks.push(x);\n    });\n    return varSliceSize(bscript.compile(chunks));\n  };\n  OptCCParams.prototype.toBuffer = function (buffer, initialOffset, asChunk) {\n    if (asChunk === void 0) {\n      asChunk = false;\n    }\n    var offset = initialOffset || 0;\n    function writeSlice(slice) {\n      offset += slice.copy(buffer, offset);\n    }\n    function writeVarInt(i) {\n      varuint.encode(i, buffer, offset);\n      offset += varuint.encode.bytes;\n    }\n    function writeVarSlice(slice) {\n      writeVarInt(slice.length);\n      writeSlice(slice);\n    }\n    var chunks = [Buffer.allocUnsafe(4)];\n    chunks[0][0] = this.version;\n    chunks[0][1] = this.evalCode;\n    chunks[0][2] = this.m;\n    chunks[0][3] = this.n;\n    this.destinations.forEach(function (x) {\n      chunks.push(x.toChunk());\n    });\n    this.vData.forEach(function (x) {\n      chunks.push(x);\n    });\n    var scriptStore = bscript.compile(chunks);\n    if (!buffer) buffer = Buffer.allocUnsafe(asChunk ? scriptStore.length : varSliceSize(scriptStore));\n    if (asChunk) {\n      writeSlice(scriptStore);\n    } else {\n      writeVarSlice(scriptStore);\n    }\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined) return buffer.slice(initialOffset, offset);\n    // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n    return buffer.slice(0, offset);\n  };\n  return OptCCParams;\n}();\nmodule.exports = OptCCParams;","map":{"version":3,"names":["bscript","require","EVALS","varuint","TxDestination","bufferutils","varSliceSize","varSlice","length","encodingLength","OptCCParams","version","evalCode","m","n","destinations","serializedObjects","vData","error","prototype","getParamObject","EVAL_NONE","EVAL_STAKEGUARD","EVAL_CURRENCY_DEFINITION","EVAL_NOTARY_EVIDENCE","EVAL_EARNEDNOTARIZATION","EVAL_ACCEPTEDNOTARIZATION","EVAL_FINALIZE_NOTARIZATION","EVAL_CURRENCYSTATE","EVAL_RESERVE_TRANSFER","EVAL_RESERVE_OUTPUT","EVAL_RESERVE_DEPOSIT","EVAL_CROSSCHAIN_EXPORT","EVAL_CROSSCHAIN_IMPORT","EVAL_IDENTITY_PRIMARY","EVAL_IDENTITY_COMMITMENT","EVAL_IDENTITY_RESERVATION","EVAL_FINALIZE_EXPORT","EVAL_FEE_POOL","EVAL_NOTARY_SIGNATURE","isValid","validEval","fromChunk","chunk","writer","BufferWriter","Buffer","alloc","writeVarInt","params","fromBuffer","concat","buffer","toChunk","toBuffer","undefined","initialOffset","offset","readSlice","slice","readVarInt","vi","decode","bytes","readVarSlice","scriptInVector","chunks","decompile","Error","readUInt8","limit","loop","oneDest","push","__byteLength","allocUnsafe","forEach","x","compile","asChunk","writeSlice","copy","i","encode","writeVarSlice","scriptStore","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/optccparams.js"],"sourcesContent":["var bscript = require('./script');\nvar EVALS = require('bitcoin-ops/evals.json');\nvar varuint = require('varuint-bitcoin');\nvar TxDestination = require('./tx_destination');\nvar bufferutils = require('./bufferutils');\nfunction varSliceSize(varSlice) {\n    var length = varSlice.length;\n    return varuint.encodingLength(length) + length;\n}\nvar OptCCParams = /** @class */ (function () {\n    function OptCCParams(version, evalCode, m, n, destinations, serializedObjects) {\n        if (version === void 0) { version = 3; }\n        if (evalCode === void 0) { evalCode = 0; }\n        if (m === void 0) { m = 1; }\n        if (n === void 0) { n = 1; }\n        if (destinations === void 0) { destinations = []; }\n        if (serializedObjects === void 0) { serializedObjects = []; }\n        this.version = version;\n        this.evalCode = evalCode;\n        this.m = m;\n        this.n = n;\n        this.destinations = destinations;\n        this.vData = serializedObjects;\n        // Error variable for reporting, does not get serialized\n        this.error = null;\n    }\n    OptCCParams.prototype.getParamObject = function () {\n        switch (this.evalCode) {\n            case EVALS.EVAL_NONE:\n                {\n                    return null;\n                }\n            case EVALS.EVAL_STAKEGUARD:\n            case EVALS.EVAL_CURRENCY_DEFINITION:\n            case EVALS.EVAL_NOTARY_EVIDENCE:\n            case EVALS.EVAL_EARNEDNOTARIZATION:\n            case EVALS.EVAL_ACCEPTEDNOTARIZATION:\n            case EVALS.EVAL_FINALIZE_NOTARIZATION:\n            case EVALS.EVAL_CURRENCYSTATE:\n            case EVALS.EVAL_RESERVE_TRANSFER:\n            case EVALS.EVAL_RESERVE_OUTPUT:\n            case EVALS.EVAL_RESERVE_DEPOSIT:\n            case EVALS.EVAL_CROSSCHAIN_EXPORT:\n            case EVALS.EVAL_CROSSCHAIN_IMPORT:\n            case EVALS.EVAL_IDENTITY_PRIMARY:\n            case EVALS.EVAL_IDENTITY_COMMITMENT:\n            case EVALS.EVAL_IDENTITY_RESERVATION:\n            case EVALS.EVAL_FINALIZE_EXPORT:\n            case EVALS.EVAL_FEE_POOL:\n            case EVALS.EVAL_NOTARY_SIGNATURE:\n                {\n                    if (this.vData.length) {\n                        return this.vData[0];\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            default:\n                {\n                    return null;\n                }\n        }\n    };\n    OptCCParams.prototype.isValid = function () {\n        var validEval = false;\n        switch (this.evalCode) {\n            case EVALS.EVAL_NONE:\n                {\n                    validEval = true;\n                    break;\n                }\n            case EVALS.EVAL_STAKEGUARD:\n            case EVALS.EVAL_CURRENCY_DEFINITION:\n            case EVALS.EVAL_NOTARY_EVIDENCE:\n            case EVALS.EVAL_EARNEDNOTARIZATION:\n            case EVALS.EVAL_ACCEPTEDNOTARIZATION:\n            case EVALS.EVAL_FINALIZE_NOTARIZATION:\n            case EVALS.EVAL_CURRENCYSTATE:\n            case EVALS.EVAL_RESERVE_TRANSFER:\n            case EVALS.EVAL_RESERVE_OUTPUT:\n            case EVALS.EVAL_RESERVE_DEPOSIT:\n            case EVALS.EVAL_CROSSCHAIN_EXPORT:\n            case EVALS.EVAL_CROSSCHAIN_IMPORT:\n            case EVALS.EVAL_IDENTITY_PRIMARY:\n            case EVALS.EVAL_IDENTITY_COMMITMENT:\n            case EVALS.EVAL_IDENTITY_RESERVATION:\n            case EVALS.EVAL_FINALIZE_EXPORT:\n            case EVALS.EVAL_FEE_POOL:\n            case EVALS.EVAL_NOTARY_SIGNATURE:\n                {\n                    validEval = this.vData && this.vData.length > 0;\n                }\n        }\n        return (validEval &&\n            this.version > 0 &&\n            this.version < 4 &&\n            ((this.version < 3 && this.evalCode < 2) || (this.evalCode <= 26 && this.m <= this.n)));\n    };\n    OptCCParams.fromChunk = function (chunk) {\n        var writer = new bufferutils.BufferWriter(Buffer.alloc(varuint.encodingLength(chunk.length)), 0);\n        writer.writeVarInt(chunk.length);\n        var params = new OptCCParams();\n        params.fromBuffer(Buffer.concat([writer.buffer, chunk]));\n        return params;\n    };\n    OptCCParams.prototype.toChunk = function () {\n        return this.toBuffer(undefined, undefined, true);\n    };\n    OptCCParams.prototype.fromBuffer = function (buffer, initialOffset) {\n        if (initialOffset === void 0) { initialOffset = 0; }\n        // the first element in this buffer will be a script to decompile and get pushed data from\n        var offset = initialOffset;\n        function readSlice(n) {\n            offset += n;\n            return buffer.slice(offset - n, offset);\n        }\n        function readVarInt() {\n            var vi = varuint.decode(buffer, offset);\n            offset += varuint.decode.bytes;\n            return vi;\n        }\n        function readVarSlice() {\n            return readSlice(readVarInt());\n        }\n        var scriptInVector = readVarSlice();\n        var chunks = bscript.decompile(scriptInVector);\n        if (chunks[0].length !== 4) {\n            // invalid optional parameters header\n            this.version = 0;\n            this.error = new Error('invalid optional parameters header');\n            return initialOffset;\n        }\n        this.version = chunks[0].readUInt8(0);\n        this.evalCode = chunks[0].readUInt8(1);\n        this.m = chunks[0].readUInt8(2);\n        this.n = chunks[0].readUInt8(3);\n        // now, we should have n keys followed by data objects for later versions, otherwise all keys and one data object\n        if (this.version <= 0 ||\n            this.version > 3 ||\n            this.evalCode < 0 ||\n            this.evalCode > 0x1a || // this is the last valid eval code as of version 3\n            (this.version < 3 && this.n < 1) ||\n            this.n > 4 ||\n            (this.version < 3 && this.n >= chunks.length) ||\n            this.n > chunks.length) {\n            // invalid header values\n            this.version = 0;\n            this.error = new Error('invalid header values');\n            return initialOffset;\n        }\n        // now, we have chunks left that are either destinations or data vectors\n        var limit = this.n === chunks.length ? this.n : this.n + 1;\n        this.destinations = [];\n        var loop;\n        for (loop = 1; this.version && loop < limit; loop++) {\n            var oneDest = TxDestination.fromChunk(chunks[loop]);\n            if (oneDest.isValid()) {\n                this.destinations.push(oneDest);\n            }\n            else {\n                this.version = 0;\n                this.error = new Error('invalid destination');\n                return initialOffset;\n            }\n        }\n        for (; this.version && loop < chunks.length; loop++) {\n            this.vData.push(chunks[loop]); // is this an issue to just store as is for the data?\n        }\n        return offset;\n    };\n    OptCCParams.prototype.__byteLength = function () {\n        var chunks = [Buffer.allocUnsafe(4)];\n        chunks[0][0] = this.version;\n        chunks[0][1] = this.evalCode;\n        chunks[0][2] = this.m;\n        chunks[0][3] = this.n;\n        this.destinations.forEach(function (x) {\n            chunks.push(Buffer.allocUnsafe(x.__byteLength()));\n            x.toBuffer(chunks[chunks.length - 1]);\n        });\n        this.vData.forEach(function (x) {\n            chunks.push(x);\n        });\n        return varSliceSize(bscript.compile(chunks));\n    };\n    OptCCParams.prototype.toBuffer = function (buffer, initialOffset, asChunk) {\n        if (asChunk === void 0) { asChunk = false; }\n        var offset = initialOffset || 0;\n        function writeSlice(slice) { offset += slice.copy(buffer, offset); }\n        function writeVarInt(i) {\n            varuint.encode(i, buffer, offset);\n            offset += varuint.encode.bytes;\n        }\n        function writeVarSlice(slice) { writeVarInt(slice.length); writeSlice(slice); }\n        var chunks = [Buffer.allocUnsafe(4)];\n        chunks[0][0] = this.version;\n        chunks[0][1] = this.evalCode;\n        chunks[0][2] = this.m;\n        chunks[0][3] = this.n;\n        this.destinations.forEach(function (x) {\n            chunks.push(x.toChunk());\n        });\n        this.vData.forEach(function (x) {\n            chunks.push(x);\n        });\n        var scriptStore = bscript.compile(chunks);\n        if (!buffer)\n            buffer = Buffer.allocUnsafe(asChunk ? scriptStore.length : varSliceSize(scriptStore));\n        if (asChunk) {\n            writeSlice(scriptStore);\n        }\n        else {\n            writeVarSlice(scriptStore);\n        }\n        // avoid slicing unless necessary\n        if (initialOffset !== undefined)\n            return buffer.slice(initialOffset, offset);\n        // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n        return buffer.slice(0, offset);\n    };\n    return OptCCParams;\n}());\nmodule.exports = OptCCParams;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}