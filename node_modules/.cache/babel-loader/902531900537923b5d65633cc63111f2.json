{"ast":null,"code":"var ERRORS = require('./errors');\nvar NATIVE = require('./native');\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON;\nvar TfTypeError = ERRORS.TfTypeError;\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError;\nvar tfSubError = ERRORS.tfSubError;\nvar getValueTypeName = ERRORS.getValueTypeName;\nvar TYPES = {\n  arrayOf: function arrayOf(type) {\n    type = compile(type);\n    function _arrayOf(array, strict) {\n      if (!NATIVE.Array(array)) return false;\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      });\n    }\n    _arrayOf.toJSON = function () {\n      return '[' + tfJSON(type) + ']';\n    };\n    return _arrayOf;\n  },\n  maybe: function maybe(type) {\n    type = compile(type);\n    function _maybe(value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe);\n    }\n    _maybe.toJSON = function () {\n      return '?' + tfJSON(type);\n    };\n    return _maybe;\n  },\n  map: function map(propertyType, propertyKeyType) {\n    propertyType = compile(propertyType);\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType);\n    function _map(value, strict) {\n      if (!NATIVE.Object(value, strict)) return false;\n      if (NATIVE.Nil(value, strict)) return false;\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict);\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key');\n        }\n        try {\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        } catch (e) {\n          throw tfSubError(e, propertyName);\n        }\n      }\n      return true;\n    }\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}';\n      };\n    } else {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyType) + '}';\n      };\n    }\n    return _map;\n  },\n  object: function object(uncompiled) {\n    var type = {};\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName]);\n    }\n    function _object(value, strict) {\n      if (!NATIVE.Object(value)) return false;\n      if (NATIVE.Nil(value)) return false;\n      var propertyName;\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName];\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName);\n      }\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue;\n          throw new TfPropertyTypeError(undefined, propertyName);\n        }\n      }\n      return true;\n    }\n    _object.toJSON = function () {\n      return tfJSON(type);\n    };\n    return _object;\n  },\n  oneOf: function oneOf() {\n    var types = [].slice.call(arguments).map(compile);\n    function _oneOf(value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n    _oneOf.toJSON = function () {\n      return types.map(tfJSON).join('|');\n    };\n    return _oneOf;\n  },\n  quacksLike: function quacksLike(type) {\n    function _quacksLike(value) {\n      return type === getValueTypeName(value);\n    }\n    _quacksLike.toJSON = function () {\n      return type;\n    };\n    return _quacksLike;\n  },\n  tuple: function tuple() {\n    var types = [].slice.call(arguments).map(compile);\n    function _tuple(values, strict) {\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      }) && (!strict || values.length === arguments.length);\n    }\n    _tuple.toJSON = function () {\n      return '(' + types.map(tfJSON).join(', ') + ')';\n    };\n    return _tuple;\n  },\n  value: function value(expected) {\n    function _value(actual) {\n      return actual === expected;\n    }\n    _value.toJSON = function () {\n      return expected;\n    };\n    return _value;\n  }\n};\nfunction compile(type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(compile(type.slice(1)));\n    return NATIVE[type] || TYPES.quacksLike(type);\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) return TYPES.arrayOf(compile(type[0]));\n    return TYPES.object(type);\n  } else if (NATIVE.Function(type)) {\n    return type;\n  }\n  return TYPES.value(type);\n}\nfunction typeforce(type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true;\n    throw new TfTypeError(surrogate || type, value);\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict);\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName];\n}\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName];\n}\nvar EXTRA = require('./extra');\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName];\n}\n\n// async wrapper\nfunction __async(type, value, strict, callback) {\n  // default to falsy strict if using shorthand overload\n  if (typeof strict === 'function') return __async(type, value, false, strict);\n  try {\n    typeforce(type, value, strict);\n  } catch (e) {\n    return callback(e);\n  }\n  callback();\n}\ntypeforce.async = __async;\ntypeforce.compile = compile;\ntypeforce.TfTypeError = TfTypeError;\ntypeforce.TfPropertyTypeError = TfPropertyTypeError;\nmodule.exports = typeforce;","map":{"version":3,"names":["ERRORS","require","NATIVE","tfJSON","TfTypeError","TfPropertyTypeError","tfSubError","getValueTypeName","TYPES","arrayOf","type","compile","_arrayOf","array","strict","Array","every","value","i","typeforce","e","toJSON","maybe","_maybe","Nil","map","propertyType","propertyKeyType","_map","Object","propertyName","propertyValue","object","uncompiled","typePropertyName","_object","undefined","oneOf","types","slice","call","arguments","_oneOf","some","join","quacksLike","_quacksLike","tuple","_tuple","values","length","expected","_value","actual","String","Function","surrogate","typeName","EXTRA","__async","callback","async","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/typeforce/index.js"],"sourcesContent":["var ERRORS = require('./errors')\nvar NATIVE = require('./native')\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type) {\n    type = compile(type)\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () { return '[' + tfJSON(type) + ']' }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value, strict)) return false\n      if (NATIVE.Nil(value, strict)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  oneOf: function oneOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _oneOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _oneOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _oneOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      }) && (!strict || values.length === arguments.length)\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(compile(type.slice(1)))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) return TYPES.arrayOf(compile(type[0]))\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = require('./extra')\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\n// async wrapper\nfunction __async (type, value, strict, callback) {\n  // default to falsy strict if using shorthand overload\n  if (typeof strict === 'function') return __async(type, value, false, strict)\n\n  try {\n    typeforce(type, value, strict)\n  } catch (e) {\n    return callback(e)\n  }\n\n  callback()\n}\n\ntypeforce.async = __async\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}