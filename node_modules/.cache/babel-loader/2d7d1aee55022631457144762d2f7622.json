{"ast":null,"code":"var typeforce = require('typeforce');\nvar ECSignature = require('./ecsignature');\nvar types = require('./types');\nvar secp256k1;\nvar available = false;\ntry {\n  // secp256k1 is an optional native module used for accelerating\n  // low-level elliptic curve operations. It's nice to have, but\n  // we can live without it too\n  secp256k1 = require('secp256k1');\n  available = true;\n} catch (e) {\n  // secp256k1 is not available, this is alright\n}\n/**\n * Derive a public key from a 32 byte private key buffer.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n *\n * @param buffer {Buffer} Private key buffer\n * @param compressed {Boolean} Whether the public key should be compressed\n * @return {undefined}\n */\nvar publicKeyCreate = function (buffer, compressed) {\n  typeforce(types.tuple(types.Buffer256bit, types.Boolean), arguments);\n  if (!available) {\n    return undefined;\n  }\n  return secp256k1.publicKeyCreate(buffer, compressed);\n};\n/**\n * Create an ECDSA signature over the given message hash `hash` with\n * the private key `d`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be signed\n * @param d {BigInteger} private key which is to be used for signing\n * @return {ECSignature}\n */\nvar sign = function (hash, d) {\n  typeforce(types.tuple(types.Buffer256bit, types.BigInt), arguments);\n  if (!available) {\n    return undefined;\n  }\n  var sig = secp256k1.sign(hash, d.toBuffer(32)).signature;\n  return ECSignature.fromDER(secp256k1.signatureExport(sig));\n};\n/**\n * Verify an ECDSA signature over the given message hash `hash` with signature `sig`\n * and public key `pubkey`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be verified\n * @param sig {ECSignature} signature which is to be verified\n * @param pubkey {Buffer} public key which will be used to verify the message signature\n * @return {Boolean}\n */\nvar verify = function (hash, sig, pubkey) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature,\n  // both compressed and uncompressed public keys are fine\n  types.oneOf(types.BufferN(33), types.BufferN(65))), arguments);\n  if (!available) {\n    return undefined;\n  }\n  sig = new ECSignature(sig.r, sig.s);\n  sig = secp256k1.signatureNormalize(secp256k1.signatureImport(sig.toDER()));\n  return secp256k1.verify(hash, sig, pubkey);\n};\nmodule.exports = {\n  available: available,\n  publicKeyCreate: publicKeyCreate,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["typeforce","require","ECSignature","types","secp256k1","available","e","publicKeyCreate","buffer","compressed","tuple","Buffer256bit","Boolean","arguments","undefined","sign","hash","d","BigInt","sig","toBuffer","signature","fromDER","signatureExport","verify","pubkey","Hash256bit","oneOf","BufferN","r","s","signatureNormalize","signatureImport","toDER","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/fastcurve.js"],"sourcesContent":["var typeforce = require('typeforce');\nvar ECSignature = require('./ecsignature');\nvar types = require('./types');\nvar secp256k1;\nvar available = false;\ntry {\n    // secp256k1 is an optional native module used for accelerating\n    // low-level elliptic curve operations. It's nice to have, but\n    // we can live without it too\n    secp256k1 = require('secp256k1');\n    available = true;\n}\ncatch (e) {\n    // secp256k1 is not available, this is alright\n}\n/**\n * Derive a public key from a 32 byte private key buffer.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n *\n * @param buffer {Buffer} Private key buffer\n * @param compressed {Boolean} Whether the public key should be compressed\n * @return {undefined}\n */\nvar publicKeyCreate = function (buffer, compressed) {\n    typeforce(types.tuple(types.Buffer256bit, types.Boolean), arguments);\n    if (!available) {\n        return undefined;\n    }\n    return secp256k1.publicKeyCreate(buffer, compressed);\n};\n/**\n * Create an ECDSA signature over the given message hash `hash` with\n * the private key `d`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be signed\n * @param d {BigInteger} private key which is to be used for signing\n * @return {ECSignature}\n */\nvar sign = function (hash, d) {\n    typeforce(types.tuple(types.Buffer256bit, types.BigInt), arguments);\n    if (!available) {\n        return undefined;\n    }\n    var sig = secp256k1.sign(hash, d.toBuffer(32)).signature;\n    return ECSignature.fromDER(secp256k1.signatureExport(sig));\n};\n/**\n * Verify an ECDSA signature over the given message hash `hash` with signature `sig`\n * and public key `pubkey`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be verified\n * @param sig {ECSignature} signature which is to be verified\n * @param pubkey {Buffer} public key which will be used to verify the message signature\n * @return {Boolean}\n */\nvar verify = function (hash, sig, pubkey) {\n    typeforce(types.tuple(types.Hash256bit, types.ECSignature, \n    // both compressed and uncompressed public keys are fine\n    types.oneOf(types.BufferN(33), types.BufferN(65))), arguments);\n    if (!available) {\n        return undefined;\n    }\n    sig = new ECSignature(sig.r, sig.s);\n    sig = secp256k1.signatureNormalize(secp256k1.signatureImport(sig.toDER()));\n    return secp256k1.verify(hash, sig, pubkey);\n};\nmodule.exports = {\n    available: available,\n    publicKeyCreate: publicKeyCreate,\n    sign: sign,\n    verify: verify\n};\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIC,WAAW,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC1C,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAS,CAAC;AAC9B,IAAIG,SAAS;AACb,IAAIC,SAAS,GAAG,KAAK;AACrB,IAAI;EACA;EACA;EACA;EACAD,SAAS,GAAGH,OAAO,CAAC,WAAW,CAAC;EAChCI,SAAS,GAAG,IAAI;AACpB,CAAC,CACD,OAAOC,CAAC,EAAE;EACN;AAAA;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,eAAe,GAAG,SAAAA,CAAUC,MAAM,EAAEC,UAAU,EAAE;EAChDT,SAAS,CAACG,KAAK,CAACO,KAAK,CAACP,KAAK,CAACQ,YAAY,EAAER,KAAK,CAACS,OAAO,CAAC,EAAEC,SAAS,CAAC;EACpE,IAAI,CAACR,SAAS,EAAE;IACZ,OAAOS,SAAS;EACpB;EACA,OAAOV,SAAS,CAACG,eAAe,CAACC,MAAM,EAAEC,UAAU,CAAC;AACxD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIM,IAAI,GAAG,SAAAA,CAAUC,IAAI,EAAEC,CAAC,EAAE;EAC1BjB,SAAS,CAACG,KAAK,CAACO,KAAK,CAACP,KAAK,CAACQ,YAAY,EAAER,KAAK,CAACe,MAAM,CAAC,EAAEL,SAAS,CAAC;EACnE,IAAI,CAACR,SAAS,EAAE;IACZ,OAAOS,SAAS;EACpB;EACA,IAAIK,GAAG,GAAGf,SAAS,CAACW,IAAI,CAACC,IAAI,EAAEC,CAAC,CAACG,QAAQ,CAAC,EAAE,CAAC,CAAC,CAACC,SAAS;EACxD,OAAOnB,WAAW,CAACoB,OAAO,CAAClB,SAAS,CAACmB,eAAe,CAACJ,GAAG,CAAC,CAAC;AAC9D,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIK,MAAM,GAAG,SAAAA,CAAUR,IAAI,EAAEG,GAAG,EAAEM,MAAM,EAAE;EACtCzB,SAAS,CAACG,KAAK,CAACO,KAAK,CAACP,KAAK,CAACuB,UAAU,EAAEvB,KAAK,CAACD,WAAW;EACzD;EACAC,KAAK,CAACwB,KAAK,CAACxB,KAAK,CAACyB,OAAO,CAAC,EAAE,CAAC,EAAEzB,KAAK,CAACyB,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,EAAEf,SAAS,CAAC;EAC9D,IAAI,CAACR,SAAS,EAAE;IACZ,OAAOS,SAAS;EACpB;EACAK,GAAG,GAAG,IAAIjB,WAAW,CAACiB,GAAG,CAACU,CAAC,EAAEV,GAAG,CAACW,CAAC,CAAC;EACnCX,GAAG,GAAGf,SAAS,CAAC2B,kBAAkB,CAAC3B,SAAS,CAAC4B,eAAe,CAACb,GAAG,CAACc,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1E,OAAO7B,SAAS,CAACoB,MAAM,CAACR,IAAI,EAAEG,GAAG,EAAEM,MAAM,CAAC;AAC9C,CAAC;AACDS,MAAM,CAACC,OAAO,GAAG;EACb9B,SAAS,EAAEA,SAAS;EACpBE,eAAe,EAAEA,eAAe;EAChCQ,IAAI,EAAEA,IAAI;EACVS,MAAM,EAAEA;AACZ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}