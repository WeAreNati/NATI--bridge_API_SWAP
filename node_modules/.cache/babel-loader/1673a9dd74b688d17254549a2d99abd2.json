{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\nconst __1 = require(\"..\");\nconst vdxf_1 = require(\"../../constants/vdxf\");\nconst address_1 = require(\"../../utils/address\");\nconst bufferutils_1 = require(\"../../utils/bufferutils\");\nconst varuint_1 = require(\"../../utils/varuint\");\nclass Context extends __1.VDXFObject {\n  constructor(kv = {}, vdxfkey = __1.LOGIN_CONSENT_CONTEXT_VDXF_KEY.vdxfid) {\n    super(vdxfkey);\n    this.kv = kv;\n  }\n  dataByteLength() {\n    let length = 0;\n    const keys = Object.keys(this.kv);\n    length += varuint_1.default.encodingLength(keys.length);\n    for (const key of keys) {\n      const value = this.kv[key];\n      if (value != null) {\n        const valueBuf = Buffer.from(value, \"utf-8\");\n        length += (0, address_1.fromBase58Check)(key).hash.length;\n        length += valueBuf.length + varuint_1.default.encodingLength(valueBuf.length);\n      }\n    }\n    return length;\n  }\n  toDataBuffer() {\n    const buffer = Buffer.alloc(this.dataByteLength());\n    const writer = new bufferutils_1.default.BufferWriter(buffer);\n    const keys = Object.keys(this.kv);\n    writer.writeCompactSize(keys.length);\n    for (const key of Object.keys(this.kv)) {\n      const value = this.kv[key];\n      const valueBuf = Buffer.from(value, \"utf-8\");\n      writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n      writer.writeVarSlice(valueBuf);\n    }\n    return writer.buffer;\n  }\n  fromDataBuffer(buffer, offset) {\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    const contextLength = reader.readCompactSize();\n    if (contextLength == 0) {\n      this.kv = {};\n      return reader.offset;\n    } else {\n      const numKeys = reader.readCompactSize();\n      for (let i = 0; i < numKeys; i++) {\n        this.kv[(0, address_1.toBase58Check)(reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH), vdxf_1.I_ADDR_VERSION)] = reader.readVarSlice().toString(\"utf-8\");\n      }\n      return reader.offset;\n    }\n  }\n  toJson() {\n    return {\n      kv: this.kv,\n      vdxfkey: this.vdxfkey\n    };\n  }\n}\nexports.Context = Context;","map":{"version":3,"names":["Object","defineProperty","exports","value","Context","__1","require","vdxf_1","address_1","bufferutils_1","varuint_1","VDXFObject","constructor","kv","vdxfkey","LOGIN_CONSENT_CONTEXT_VDXF_KEY","vdxfid","dataByteLength","length","keys","default","encodingLength","key","valueBuf","Buffer","from","fromBase58Check","hash","toDataBuffer","buffer","alloc","writer","BufferWriter","writeCompactSize","writeSlice","writeVarSlice","fromDataBuffer","offset","reader","BufferReader","contextLength","readCompactSize","numKeys","i","toBase58Check","readSlice","HASH160_BYTE_LENGTH","I_ADDR_VERSION","readVarSlice","toString","toJson"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/vdxf/classes/Context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst __1 = require(\"..\");\nconst vdxf_1 = require(\"../../constants/vdxf\");\nconst address_1 = require(\"../../utils/address\");\nconst bufferutils_1 = require(\"../../utils/bufferutils\");\nconst varuint_1 = require(\"../../utils/varuint\");\nclass Context extends __1.VDXFObject {\n    constructor(kv = {}, vdxfkey = __1.LOGIN_CONSENT_CONTEXT_VDXF_KEY.vdxfid) {\n        super(vdxfkey);\n        this.kv = kv;\n    }\n    dataByteLength() {\n        let length = 0;\n        const keys = Object.keys(this.kv);\n        length += varuint_1.default.encodingLength(keys.length);\n        for (const key of keys) {\n            const value = this.kv[key];\n            if (value != null) {\n                const valueBuf = Buffer.from(value, \"utf-8\");\n                length += (0, address_1.fromBase58Check)(key).hash.length;\n                length += valueBuf.length + varuint_1.default.encodingLength(valueBuf.length);\n            }\n        }\n        return length;\n    }\n    toDataBuffer() {\n        const buffer = Buffer.alloc(this.dataByteLength());\n        const writer = new bufferutils_1.default.BufferWriter(buffer);\n        const keys = Object.keys(this.kv);\n        writer.writeCompactSize(keys.length);\n        for (const key of Object.keys(this.kv)) {\n            const value = this.kv[key];\n            const valueBuf = Buffer.from(value, \"utf-8\");\n            writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n            writer.writeVarSlice(valueBuf);\n        }\n        return writer.buffer;\n    }\n    fromDataBuffer(buffer, offset) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        const contextLength = reader.readCompactSize();\n        if (contextLength == 0) {\n            this.kv = {};\n            return reader.offset;\n        }\n        else {\n            const numKeys = reader.readCompactSize();\n            for (let i = 0; i < numKeys; i++) {\n                this.kv[(0, address_1.toBase58Check)(reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH), vdxf_1.I_ADDR_VERSION)] = reader.readVarSlice().toString(\"utf-8\");\n            }\n            return reader.offset;\n        }\n    }\n    toJson() {\n        return {\n            kv: this.kv,\n            vdxfkey: this.vdxfkey,\n        };\n    }\n}\nexports.Context = Context;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}