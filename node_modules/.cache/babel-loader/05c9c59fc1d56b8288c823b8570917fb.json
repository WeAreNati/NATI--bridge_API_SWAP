{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toIAddress = exports.nameAndParentAddrToIAddr = exports.toBase58Check = exports.fromBase58Check = void 0;\nconst hash_1 = require(\"./hash\");\nconst bs58check = require(\"bs58check\");\nconst fromBase58Check = address => {\n  var payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + \" is too short\");\n  if (payload.length > 22) throw new TypeError(address + \" is too long\");\n  var multibyte = payload.length === 22;\n  var offset = multibyte ? 2 : 1;\n  var version = multibyte ? payload.readUInt16BE(0) : payload[0];\n  var hash = payload.slice(offset);\n  // Turn hash to buffer with Buffer.from due to strange bug where certain JS engines\n  // don't keep hash a buffer\n  return {\n    version: version,\n    hash: Buffer.from(hash)\n  };\n};\nexports.fromBase58Check = fromBase58Check;\nconst toBase58Check = (hash, version) => {\n  // Zcash adds an extra prefix resulting in a bigger (22 bytes) payload. We identify them Zcash by checking if the\n  // version is multibyte (2 bytes instead of 1)\n  var multibyte = version > 0xff;\n  var size = multibyte ? 22 : 21;\n  var offset = multibyte ? 2 : 1;\n  var payload = Buffer.allocUnsafe(size);\n  multibyte ? payload.writeUInt16BE(version, 0) : payload.writeUInt8(version, 0);\n  hash.copy(payload, offset);\n  return bs58check.encode(payload);\n};\nexports.toBase58Check = toBase58Check;\nconst nameAndParentAddrToIAddr = (name, parentIAddr) => {\n  let idHash;\n  const nameBuffer = Buffer.from(name.toLowerCase(), \"utf8\");\n  if (parentIAddr == null) {\n    idHash = (0, hash_1.hash)(nameBuffer);\n  } else {\n    idHash = (0, hash_1.hash)(nameBuffer);\n    idHash = (0, hash_1.hash)((0, exports.fromBase58Check)(parentIAddr).hash, idHash);\n  }\n  return (0, exports.toBase58Check)((0, hash_1.hash160)(idHash), 102);\n};\nexports.nameAndParentAddrToIAddr = nameAndParentAddrToIAddr;\nconst toIAddress = (fullyqualifiedname, rootSystemName = \"\") => {\n  const splitFqnAt = fullyqualifiedname.split(\"@\").filter(x => x.length > 0);\n  if (splitFqnAt.length !== 1) throw new Error(\"Invalid name\");\n  const cleanFqn = splitFqnAt[0];\n  const splitFqnDot = cleanFqn.split('.');\n  if (splitFqnDot[splitFqnDot.length - 1] !== rootSystemName && splitFqnDot[splitFqnDot.length - 1] !== \"\") {\n    splitFqnDot.push(rootSystemName);\n  }\n  const name = splitFqnDot.shift();\n  let Parent;\n  for (let i = splitFqnDot.length - 1; i >= 0; i--) {\n    let idHash;\n    const parentName = Buffer.from(splitFqnDot[i].toLowerCase(), \"utf8\");\n    if (parentName.length > 0) {\n      if (Parent == null) {\n        idHash = (0, hash_1.hash)(parentName);\n      } else {\n        idHash = (0, hash_1.hash)(parentName);\n        idHash = (0, hash_1.hash)(Parent, idHash);\n      }\n      Parent = (0, hash_1.hash160)(idHash);\n    }\n  }\n  let idHash;\n  const nameBuffer = Buffer.from(name.toLowerCase(), \"utf8\");\n  if (Parent == null) {\n    idHash = (0, hash_1.hash)(nameBuffer);\n  } else {\n    idHash = (0, hash_1.hash)(nameBuffer);\n    idHash = (0, hash_1.hash)(Parent, idHash);\n  }\n  return (0, exports.toBase58Check)((0, hash_1.hash160)(idHash), 102);\n};\nexports.toIAddress = toIAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","toIAddress","nameAndParentAddrToIAddr","toBase58Check","fromBase58Check","hash_1","require","bs58check","address","payload","decode","length","TypeError","multibyte","offset","version","readUInt16BE","hash","slice","Buffer","from","size","allocUnsafe","writeUInt16BE","writeUInt8","copy","encode","name","parentIAddr","idHash","nameBuffer","toLowerCase","hash160","fullyqualifiedname","rootSystemName","splitFqnAt","split","filter","x","Error","cleanFqn","splitFqnDot","push","shift","Parent","i","parentName"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/utils/address.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toIAddress = exports.nameAndParentAddrToIAddr = exports.toBase58Check = exports.fromBase58Check = void 0;\nconst hash_1 = require(\"./hash\");\nconst bs58check = require(\"bs58check\");\nconst fromBase58Check = (address) => {\n    var payload = bs58check.decode(address);\n    // TODO: 4.0.0, move to \"toOutputScript\"\n    if (payload.length < 21)\n        throw new TypeError(address + \" is too short\");\n    if (payload.length > 22)\n        throw new TypeError(address + \" is too long\");\n    var multibyte = payload.length === 22;\n    var offset = multibyte ? 2 : 1;\n    var version = multibyte ? payload.readUInt16BE(0) : payload[0];\n    var hash = payload.slice(offset);\n    // Turn hash to buffer with Buffer.from due to strange bug where certain JS engines\n    // don't keep hash a buffer\n    return { version: version, hash: Buffer.from(hash) };\n};\nexports.fromBase58Check = fromBase58Check;\nconst toBase58Check = (hash, version) => {\n    // Zcash adds an extra prefix resulting in a bigger (22 bytes) payload. We identify them Zcash by checking if the\n    // version is multibyte (2 bytes instead of 1)\n    var multibyte = version > 0xff;\n    var size = multibyte ? 22 : 21;\n    var offset = multibyte ? 2 : 1;\n    var payload = Buffer.allocUnsafe(size);\n    multibyte\n        ? payload.writeUInt16BE(version, 0)\n        : payload.writeUInt8(version, 0);\n    hash.copy(payload, offset);\n    return bs58check.encode(payload);\n};\nexports.toBase58Check = toBase58Check;\nconst nameAndParentAddrToIAddr = (name, parentIAddr) => {\n    let idHash;\n    const nameBuffer = Buffer.from(name.toLowerCase(), \"utf8\");\n    if (parentIAddr == null) {\n        idHash = (0, hash_1.hash)(nameBuffer);\n    }\n    else {\n        idHash = (0, hash_1.hash)(nameBuffer);\n        idHash = (0, hash_1.hash)((0, exports.fromBase58Check)(parentIAddr).hash, idHash);\n    }\n    return (0, exports.toBase58Check)((0, hash_1.hash160)(idHash), 102);\n};\nexports.nameAndParentAddrToIAddr = nameAndParentAddrToIAddr;\nconst toIAddress = (fullyqualifiedname, rootSystemName = \"\") => {\n    const splitFqnAt = fullyqualifiedname.split(\"@\").filter(x => x.length > 0);\n    if (splitFqnAt.length !== 1)\n        throw new Error(\"Invalid name\");\n    const cleanFqn = splitFqnAt[0];\n    const splitFqnDot = cleanFqn.split('.');\n    if (splitFqnDot[splitFqnDot.length - 1] !== rootSystemName &&\n        splitFqnDot[splitFqnDot.length - 1] !== \"\") {\n        splitFqnDot.push(rootSystemName);\n    }\n    const name = splitFqnDot.shift();\n    let Parent;\n    for (let i = splitFqnDot.length - 1; i >= 0; i--) {\n        let idHash;\n        const parentName = Buffer.from(splitFqnDot[i].toLowerCase(), \"utf8\");\n        if (parentName.length > 0) {\n            if (Parent == null) {\n                idHash = (0, hash_1.hash)(parentName);\n            }\n            else {\n                idHash = (0, hash_1.hash)(parentName);\n                idHash = (0, hash_1.hash)(Parent, idHash);\n            }\n            Parent = (0, hash_1.hash160)(idHash);\n        }\n    }\n    let idHash;\n    const nameBuffer = Buffer.from(name.toLowerCase(), \"utf8\");\n    if (Parent == null) {\n        idHash = (0, hash_1.hash)(nameBuffer);\n    }\n    else {\n        idHash = (0, hash_1.hash)(nameBuffer);\n        idHash = (0, hash_1.hash)(Parent, idHash);\n    }\n    return (0, exports.toBase58Check)((0, hash_1.hash160)(idHash), 102);\n};\nexports.toIAddress = toIAddress;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}