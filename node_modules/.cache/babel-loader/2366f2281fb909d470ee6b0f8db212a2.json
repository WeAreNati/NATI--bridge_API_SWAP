{"ast":null,"code":"import BigNumber from'bignumber.js';export const isRAddress=address=>/^R[1-9A-HJ-NP-Za-km-z]{33,34}$/.test(address);export const isiAddress=address=>/^i[1-9A-HJ-NP-Za-km-z]{33,34}$/.test(address);export const isETHAddressAsync=async address=>{const response=await fetch('./exclude.json');let excludeFound=true;try{const excludeList=await response.json();excludeFound=(excludeList===null||excludeList===void 0?void 0:excludeList.ETH.findIndex(element=>{return element.toLowerCase()===address.toLowerCase();}))===-1;}catch(e){}const ETHPassesRegex=/^(0x)?[0-9a-fA-F]{40}$/.test(address);const retval=excludeFound&&ETHPassesRegex;return retval;};export const isETHAddress=address=>{const ETHPassesRegex=/^(0x)?[0-9a-fA-F]{40}$/.test(address);return ETHPassesRegex;};export const validateAddress=async address=>{if(isiAddress(address)||isRAddress(address)||(await isETHAddressAsync(address))){return true;}else{return'Address is not valid';}};export const validateNFTAddress=address=>{if(isiAddress(address)||isRAddress(address)){return true;}else{return'Address is not valid';}};export const NFTAddressType=address=>{if(isiAddress(address))return 4;else if(isRAddress(address))return 2;else return'Address is not valid';};export const validateClaimAddress=(address,usePublicKey)=>{if(usePublicKey){return true;}if(isiAddress(address)||isRAddress(address)){return true;}else{return'Address is not valid';}};export const uint64ToVerusFloat=number=>{const input=BigInt(number);let inter=\"\".concat(input/BigInt(100000000),\".\");let decimalp=\"\".concat(input%BigInt(100000000));if(input<0){inter=\"-\".concat(inter);decimalp=decimalp.slice(1);}while(decimalp.length<8){decimalp=\"0\".concat(decimalp);}return inter+decimalp;};export const coinsToUnits=(coin,decimals)=>{return coin.multipliedBy(BigNumber(10).pow(BigNumber(decimals)));};export const coinsToSats=coins=>{BigNumber.set({EXPONENTIAL_AT:1000000,ROUNDING_MODE:BigNumber.ROUND_FLOOR});let input=BigNumber(coins);return BigNumber(coinsToUnits(input,8).toFixed(0)).toString();};","map":{"version":3,"names":["BigNumber","isRAddress","address","test","isiAddress","isETHAddressAsync","response","fetch","excludeFound","excludeList","json","ETH","findIndex","element","toLowerCase","e","ETHPassesRegex","retval","isETHAddress","validateAddress","validateNFTAddress","NFTAddressType","validateClaimAddress","usePublicKey","uint64ToVerusFloat","number","input","BigInt","inter","concat","decimalp","slice","length","coinsToUnits","coin","decimals","multipliedBy","pow","coinsToSats","coins","set","EXPONENTIAL_AT","ROUNDING_MODE","ROUND_FLOOR","toFixed","toString"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/src/utils/rules.js"],"sourcesContent":["import BigNumber from 'bignumber.js';\r\n\r\nexport const isRAddress = (address) => (/^R[1-9A-HJ-NP-Za-km-z]{33,34}$/).test(address);\r\nexport const isiAddress = (address) => (/^i[1-9A-HJ-NP-Za-km-z]{33,34}$/).test(address);\r\n\r\nexport const isETHAddressAsync = async (address) => {\r\n  const response = await fetch('./exclude.json');\r\n  let excludeFound = true;\r\n  try {\r\n    const excludeList = await response.json();\r\n    excludeFound = excludeList?.ETH.findIndex(element => {\r\n      return element.toLowerCase() === address.toLowerCase();\r\n    }) === -1;\r\n  } catch (e) {\r\n\r\n  }\r\n\r\n  const ETHPassesRegex = (/^(0x)?[0-9a-fA-F]{40}$/).test(address);\r\n  const retval = excludeFound && ETHPassesRegex;\r\n  return retval;\r\n}\r\n\r\nexport const isETHAddress = (address) => {\r\n  const ETHPassesRegex = (/^(0x)?[0-9a-fA-F]{40}$/).test(address);\r\n  return ETHPassesRegex;\r\n}\r\n\r\nexport const validateAddress = async (address) => {\r\n\r\n  if (isiAddress(address) || isRAddress(address) || await isETHAddressAsync(address)) {\r\n    return true\r\n  } else {\r\n    return 'Address is not valid'\r\n  }\r\n\r\n}\r\n\r\nexport const validateNFTAddress = (address) => {\r\n  if (isiAddress(address) || isRAddress(address)) {\r\n    return true\r\n  } else {\r\n    return 'Address is not valid'\r\n  }\r\n}\r\n\r\nexport const NFTAddressType = (address) => {\r\n  if (isiAddress(address))\r\n    return 4;\r\n  else if (isRAddress(address))\r\n    return 2;\r\n  else\r\n    return 'Address is not valid'\r\n\r\n}\r\n\r\nexport const validateClaimAddress = (address, usePublicKey) => {\r\n\r\n  if (usePublicKey) {\r\n    return true;\r\n  } if (isiAddress(address) || isRAddress(address)) {\r\n    return true\r\n  } else {\r\n    return 'Address is not valid'\r\n  }\r\n}\r\n\r\nexport const uint64ToVerusFloat = (number) => {\r\n\r\n  const input = BigInt(number);\r\n  let inter = `${(input / BigInt(100000000))}.`\r\n  let decimalp = `${(input % BigInt(100000000))}`\r\n\r\n  if (input < 0) {\r\n    inter = `-${inter}`;\r\n    decimalp = decimalp.slice(1);\r\n  }\r\n\r\n  while (decimalp.length < 8) {\r\n    decimalp = `0${decimalp}`;\r\n  }\r\n  return (inter + decimalp)\r\n}\r\n\r\nexport const coinsToUnits = (coin, decimals) => {\r\n  return coin.multipliedBy(BigNumber(10).pow(BigNumber(decimals)))\r\n}\r\n\r\nexport const coinsToSats = (coins) => {\r\n  BigNumber.set({ EXPONENTIAL_AT: 1000000, ROUNDING_MODE: BigNumber.ROUND_FLOOR });\r\n  let input = BigNumber(coins);\r\n\r\n  return BigNumber(coinsToUnits(input, 8).toFixed(0)).toString();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}