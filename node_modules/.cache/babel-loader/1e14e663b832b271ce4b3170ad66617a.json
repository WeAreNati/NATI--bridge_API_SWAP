{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\nvar baddress = require('./address');\nvar bcrypto = require('./crypto');\nvar bscript = require('./script');\nvar btemplates = require('./templates');\nvar coins = require('./coins');\nvar networks = require('./networks');\nvar ops = require('bitcoin-ops');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG, btemplates.types.SMART_TRANSACTION];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\nvar ECPair = require('./ecpair');\nvar ECSignature = require('./ecsignature');\nvar Transaction = require('./transaction');\nvar SmartTransactionSignatures = require('./smart_transaction_signatures');\nvar SmartTransactionSignature = require('./smart_transaction_signature');\nvar getMainnet = require('./coins').getMainnet;\nvar debug = require('debug')('bitgo:utxolib:txbuilder');\nfunction supportedType(type) {\n  return SIGNABLE.indexOf(type) !== -1;\n}\nfunction supportedP2SHType(type) {\n  return P2SH.indexOf(type) !== -1;\n}\nfunction extractChunks(type, chunks, script) {\n  var pubKeys = [];\n  var signatures = [];\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1);\n      signatures = chunks.slice(0, 1);\n      break;\n    case scriptTypes.SMART_TRANSACTION:\n      signatures = [chunks[0]];\n      break;\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n      signatures = chunks.slice(0, 1);\n      break;\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script);\n        pubKeys = multisig.pubKeys;\n      }\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk;\n      });\n      break;\n  }\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  };\n}\nfunction expandInput(scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  var prevOutScript;\n  var prevOutType;\n  var scriptType;\n  var script;\n  var redeemScript;\n  var witnessScript;\n  var witnessScriptType;\n  var redeemScriptType;\n  var witness = false;\n  var p2wsh = false;\n  var p2sh = false;\n  var witnessProgram;\n  var chunks;\n  var scriptSigChunks = bscript.decompile(scriptSig);\n  var sigType = btemplates.classifyInput(scriptSigChunks, true);\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true;\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n    redeemScriptType = btemplates.classifyOutput(redeemScript);\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n    prevOutType = scriptTypes.P2SH;\n    script = redeemScript;\n  }\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1];\n    witnessScriptType = btemplates.classifyOutput(witnessScript);\n    p2wsh = true;\n    witness = true;\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      prevOutType = scriptTypes.P2WSH;\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary');\n      }\n      // bare witness\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n      }\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript');\n      }\n    }\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script');\n    }\n    script = witnessScript;\n    scriptType = witnessScriptType;\n    chunks = witnessStack.slice(0, -1);\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true;\n    var key = witnessStack[witnessStack.length - 1];\n    var keyHash = bcrypto.hash160(key);\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      prevOutType = scriptTypes.P2WPKH;\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary');\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n      }\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program');\n      }\n    }\n    scriptType = scriptTypes.P2PKH;\n    chunks = witnessStack;\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!');\n    }\n    script = redeemScript;\n    scriptType = redeemScriptType;\n    chunks = scriptSigChunks.slice(0, -1);\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n    chunks = scriptSigChunks;\n  }\n  var expanded = extractChunks(scriptType, chunks, script);\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  };\n  if (p2sh) {\n    result.redeemScript = redeemScript;\n    result.redeemScriptType = redeemScriptType;\n  }\n  if (p2wsh) {\n    result.witnessScript = witnessScript;\n    result.witnessScriptType = witnessScriptType;\n  }\n  return result;\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin, value, network) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return;\n  if (input.pubKeys.length === input.signatures.length) return;\n  network = network || networks.bitcoin;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n    var match;\n    // check for a signature\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      if (coins.isZcash(network) && value === undefined) {\n        return false;\n      }\n      // TODO: avoid O(n) hashForSignature\n      var parsed = ECSignature.parseScriptSignature(signature);\n      var hash = transaction.hashForSignatureByNetwork(vin, input.signScript, value, parsed.hashType, !!input.witness);\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var scriptChunks = bscript.decompile(script);\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script);\n  }\n  var pubKeys = [];\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break;\n      var pkh1 = scriptChunks[2];\n      var pkh2 = bcrypto.hash160(ourPubKey);\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey];\n      break;\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break;\n      var wpkh1 = scriptChunks[1];\n      var wpkh2 = bcrypto.hash160(ourPubKey);\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey];\n      break;\n    case scriptTypes.SMART_TRANSACTION:\n      if (!ourPubKey) break;\n      pubKeys = [ourPubKey];\n      break;\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1);\n      break;\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2);\n      break;\n    default:\n      return {\n        scriptType: scriptType\n      };\n  }\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () {\n      return undefined;\n    })\n  };\n}\nfunction checkP2SHInput(input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH');\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)');\n  }\n}\nfunction checkP2WSHInput(input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH');\n    var scriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)');\n  }\n}\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded;\n  var prevOutType;\n  var prevOutScript;\n  var p2sh = false;\n  var p2shType;\n  var redeemScriptHash;\n  var witness = false;\n  var p2wsh = false;\n  var witnessType;\n  var witnessScriptHash;\n  var signType;\n  var signScript;\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2SHInput(input, redeemScriptHash);\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script');\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = witness = p2wsh = true;\n    p2shType = btemplates.types.P2WSH;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    checkP2SHInput(input, redeemScriptHash);\n    expanded = expandOutput(redeemScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = true;\n    signType = p2shType = expanded.scriptType;\n    signScript = redeemScript;\n    witness = signType === btemplates.types.P2WPKH;\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2WSHInput(input, witnessScriptHash);\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2WSH;\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n    witness = p2wsh = true;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH || input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    }\n    prevOutType = input.prevOutType;\n    prevOutScript = input.prevOutScript;\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n    if (!expanded.pubKeys) return;\n    witness = input.prevOutType === scriptTypes.P2WPKH;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n    prevOutType = scriptTypes.P2PKH;\n    witness = false;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  }\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n  }\n  if (p2sh) {\n    input.redeemScript = redeemScript;\n    input.redeemScriptType = p2shType;\n  }\n  if (p2wsh) {\n    input.witnessScript = witnessScript;\n    input.witnessScriptType = witnessType;\n  }\n  input.pubKeys = expanded.pubKeys;\n  input.signatures = expanded.signatures;\n  input.signScript = signScript;\n  input.signType = signType;\n  input.prevOutScript = prevOutScript;\n  input.prevOutType = prevOutType;\n  input.witness = witness;\n}\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n  } else if (type === scriptTypes.SMART_TRANSACTION) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.smartTransaction.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0;\n      });\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) {\n          return x !== ops.OP_0;\n        });\n      }\n      return btemplates.multisig.input.encodeStack(signatures);\n    }\n  } else {\n    throw new Error('Not yet supported');\n  }\n  if (!allowIncomplete) throw new Error('Not enough signatures provided');\n  return [];\n}\nfunction buildInput(input, allowIncomplete) {\n  var scriptType = input.prevOutType;\n  var sig = [];\n  var witness = [];\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n  }\n  var p2sh = false;\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type');\n    }\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n    }\n    // If it wasn't SIGNABLE, it's witness, defer to that\n    if (input.redeemScriptType) {\n      p2sh = true;\n      scriptType = input.redeemScriptType;\n    }\n  }\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n      break;\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type');\n      }\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        witness.push(input.witnessScript);\n        scriptType = input.witnessScriptType;\n      }\n      break;\n  }\n  // append redeemScript if necessary\n  if (p2sh) {\n    sig.push(input.redeemScript);\n  }\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  };\n}\n// By default, assume is a bitcoin transaction\nfunction TransactionBuilder(network, maximumFeeRate) {\n  this.prevTxMap = {};\n  this.network = network || networks.bitcoin;\n  // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n  this.maximumFeeRate = maximumFeeRate || 2500;\n  this.inputs = [];\n  this.tx = new Transaction(this.network);\n}\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime);\n  // if any signatures exist, throw\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false;\n    return input.signatures.some(function (s) {\n      return s;\n    });\n  })) {\n    throw new Error('No, this would invalidate signatures');\n  }\n  this.tx.locktime = locktime;\n};\nTransactionBuilder.prototype.setVersion = function (version, overwinter) {\n  if (overwinter === void 0) {\n    overwinter = true;\n  }\n  typeforce(types.UInt32, version);\n  if (coins.isZcashCompatible(this.network)) {\n    if (!this.network.consensusBranchId.hasOwnProperty(this.tx.version)) {\n      /* istanbul ignore next */\n      throw new Error('Unsupported Zcash transaction');\n    }\n    this.tx.overwintered = overwinter ? 1 : 0;\n    this.tx.consensusBranchId = this.network.consensusBranchId[version];\n  }\n  this.tx.version = version;\n};\nTransactionBuilder.prototype.setConsensusBranchId = function (consensusBranchId) {\n  if (!coins.isZcashCompatible(this.network)) {\n    throw new Error('consensusBranchId can only be set for Zcash or compatible transactions');\n  }\n  if (!this.inputs.every(function (input) {\n    if (input.prevOutType === scriptTypes.SMART_TRANSACTION) {\n      if (input.signatures === undefined || input.signatures.length === 0) return true;\n      var smartTxSigs = SmartTransactionSignatures.fromChunk(bscript.decompile(input.signatures)[0]);\n      if (smartTxSigs.error != null || smartTxSigs.signatures.length === 0 || smartTxSigs.signatures.every(function (sig) {\n        return sig.oneSignature.length === 0;\n      })) {\n        return true;\n      }\n    }\n    return input.signatures === undefined;\n  })) {\n    /* istanbul ignore next */\n    throw new Error('Changing the consensusBranchId for a partially signed transaction would invalidate signatures');\n  }\n  typeforce(types.UInt32, consensusBranchId);\n  this.tx.consensusBranchId = consensusBranchId;\n};\nTransactionBuilder.prototype.setVersionGroupId = function (versionGroupId) {\n  if (!(coins.isZcashCompatible(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n  typeforce(types.UInt32, versionGroupId);\n  this.tx.versionGroupId = versionGroupId;\n};\nTransactionBuilder.prototype.setExpiryHeight = function (expiryHeight) {\n  if (!(coins.isZcashCompatible(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash or compatible networks starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n  typeforce(types.UInt32, expiryHeight);\n  this.tx.expiryHeight = expiryHeight;\n};\nTransactionBuilder.prototype.setJoinSplits = function (transaction) {\n  if (!(coins.isZcashCompatible(this.network) && this.tx.supportsJoinSplits())) {\n    throw new Error('joinsplits can only be set for Zcash or compatible networks starting at version 2. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n  if (transaction && transaction.joinsplits) {\n    this.tx.joinsplits = transaction.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zproof: txJoinsplit.zproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      };\n    });\n    this.tx.joinsplitPubkey = transaction.joinsplitPubkey;\n    this.tx.joinsplitSig = transaction.joinsplitSig;\n    return;\n  }\n  throw new Error('Invalid transaction with joinsplits');\n};\nTransactionBuilder.fromTransaction = function (transaction, network) {\n  var txbNetwork = network || networks.bitcoin;\n  var txb = new TransactionBuilder(txbNetwork);\n  if (getMainnet(txb.network) !== getMainnet(transaction.network)) {\n    throw new Error('This transaction is incompatible with the transaction builder');\n  }\n  // Copy transaction fields\n  txb.setVersion(transaction.version, transaction.overwintered);\n  txb.setLockTime(transaction.locktime);\n  if (coins.isZcashCompatible(txbNetwork)) {\n    // Copy Zcash overwinter fields. Omitted if the transaction builder is not for Zcash.\n    if (txb.tx.isOverwinterCompatible()) {\n      txb.setVersionGroupId(transaction.versionGroupId);\n      txb.setExpiryHeight(transaction.expiryHeight);\n    }\n    txb.setConsensusBranchId(transaction.consensusBranchId);\n  }\n  // Copy Dash special transaction fields. Omitted if the transaction builder is not for Dash.\n  if (coins.isDash(txbNetwork)) {\n    typeforce(types.UInt16, transaction.type);\n    txb.tx.type = transaction.type;\n    if (txb.tx.versionSupportsDashSpecialTransactions()) {\n      typeforce(types.Buffer, transaction.extraPayload);\n      txb.tx.extraPayload = transaction.extraPayload;\n    }\n  }\n  // Copy outputs (done first to avoid signature invalidation)\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value);\n  });\n  // Copy inputs\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    });\n  });\n  // fix some things not possible through the public API\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, txbNetwork);\n  });\n  return txb;\n};\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n  var value;\n  // is it a hex string?\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse();\n    // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout];\n    prevOutScript = txOut.script;\n    value = txOut.value;\n    txHash = txHash.getHash();\n  }\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  });\n};\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported');\n  }\n  var prevTxOut = txHash.toString('hex') + ':' + vout;\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n  var input = {};\n  // derive what we can from the scriptSig\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || []);\n  }\n  // if an input value was given, retain it\n  if (options.value !== undefined) {\n    input.value = options.value;\n  }\n  // derive what we can from the previous transactions output script\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType;\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript);\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys;\n        input.signatures = expanded.signatures;\n      }\n      prevOutType = expanded.scriptType;\n    }\n    input.prevOutScript = options.prevOutScript;\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n  }\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.script);\n  this.inputs[vin] = input;\n  this.prevTxMap[prevTxOut] = vin;\n  return vin;\n};\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n  // Attempt to get a script if it's a base58 address string\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n  }\n  return this.tx.addOutput(scriptPubKey, value);\n};\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false);\n};\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true);\n};\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs');\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs');\n  }\n  var tx = this.tx.clone();\n  // Create script signatures from inputs\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete');\n    var result = buildInput(input, allowIncomplete);\n    // skip if no result\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported');\n      }\n    }\n    tx.setInputScript(i, result.script);\n    tx.setWitness(i, result.witness);\n  });\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees');\n    }\n  }\n  return tx;\n};\nfunction canSign(input) {\n  return input.prevOutScript !== undefined && input.signScript !== undefined && input.pubKeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubKeys.length && input.pubKeys.length > 0 && (input.witness === false || input.witness === true && input.value !== undefined);\n}\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n  debug('Signing transaction: (input: %d, hashType: %d, witnessVal: %s, witnessScript: %j)', vin, hashType, witnessValue, witnessScript);\n  debug('Transaction Builder network: %j', this.network);\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== this.network) throw new TypeError('Inconsistent network');\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || Transaction.SIGHASH_ALL;\n  var input = this.inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    debug('Preparing input %d for signing', vin);\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  var signatureHash = this.tx.hashForSignatureByNetwork(vin, input.signScript, witnessValue, hashType, !!input.witness);\n  // enforce in order signing of public keys\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    if (kpPubKey.length !== 33 && input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    var signature = keyPair.sign(signatureHash);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    debug('Produced signature (r: %s, s: %s)', signature.r, signature.s);\n    if (input.signType === scriptTypes.SMART_TRANSACTION) {\n      input.signatures[i] = new SmartTransactionSignatures(1, 1, [new SmartTransactionSignature(1, 1, pubKey, signature.toCompact().slice(1))]).toChunk();\n    } else input.signatures[i] = signature.toScriptSignature(hashType);\n    return true;\n  });\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n};\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n      return hashType & Transaction.SIGHASH_ANYONECANPAY;\n    });\n  });\n};\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length;\n  var nOutputs = this.tx.outs.length;\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true;\n    if (input.signType === scriptTypes.SMART_TRANSACTION) {\n      var smartTxSigs = SmartTransactionSignatures.fromChunk(bscript.decompile(input.signatures)[0]);\n      if (smartTxSigs.error != null || smartTxSigs.signatures.length === 0 || smartTxSigs.signatures.every(function (sig) {\n        return sig.oneSignature.length === 0;\n      })) {\n        return true;\n      }\n    }\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      var hashTypeMod = hashType & 0x1f;\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true;\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs;\n      }\n    });\n  });\n};\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) {\n    return a + (x.value >>> 0);\n  }, 0);\n  // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n  var outgoing = this.tx.outs.reduce(function (a, x) {\n    return a + x.value;\n  }, 0);\n  var fee = incoming - outgoing;\n  var feeRate = fee / bytes;\n  return feeRate > this.maximumFeeRate;\n};\nmodule.exports = TransactionBuilder;","map":{"version":3,"names":["Buffer","require","baddress","bcrypto","bscript","btemplates","coins","networks","ops","typeforce","types","scriptTypes","SIGNABLE","P2PKH","P2PK","MULTISIG","SMART_TRANSACTION","P2SH","concat","P2WPKH","P2WSH","ECPair","ECSignature","Transaction","SmartTransactionSignatures","SmartTransactionSignature","getMainnet","debug","supportedType","type","indexOf","supportedP2SHType","extractChunks","chunks","script","pubKeys","signatures","slice","pubKey","output","decode","undefined","multisig","map","chunk","length","expandInput","scriptSig","witnessStack","prevOutScript","prevOutType","scriptType","redeemScript","witnessScript","witnessScriptType","redeemScriptType","witness","p2wsh","p2sh","witnessProgram","scriptSigChunks","decompile","sigType","classifyInput","classifyOutput","scriptHash","encode","hash160","classifyWitness","witnessScriptHash","sha256","Error","equals","key","keyHash","witnessPubKeyHash","expanded","result","signType","signScript","Boolean","fixMultisigOrder","input","transaction","vin","value","network","bitcoin","unmatched","keyPair","fromPublicKeyBuffer","match","some","signature","i","isZcash","parsed","parseScriptSignature","hash","hashForSignatureByNetwork","hashType","verify","expandOutput","ourPubKey","scriptChunks","pkh1","pkh2","wpkh1","wpkh2","checkP2SHInput","redeemScriptHash","prevOutScriptScriptHash","checkP2WSHInput","prepareInput","kpPubKey","witnessValue","p2shType","witnessType","toASM","pubKeyHash","buildStack","allowIncomplete","isBuffer","encodeStack","smartTransaction","OP_0","filter","x","buildInput","sig","push","compile","TransactionBuilder","maximumFeeRate","prevTxMap","inputs","tx","prototype","setLockTime","locktime","UInt32","s","setVersion","version","overwinter","isZcashCompatible","consensusBranchId","hasOwnProperty","overwintered","setConsensusBranchId","every","smartTxSigs","fromChunk","error","oneSignature","setVersionGroupId","versionGroupId","isOverwinterCompatible","coin","setExpiryHeight","expiryHeight","setJoinSplits","supportsJoinSplits","joinsplits","txJoinsplit","vpubOld","vpubNew","anchor","nullifiers","commitments","ephemeralKey","randomSeed","macs","zproof","ciphertexts","joinsplitPubkey","joinsplitSig","fromTransaction","txbNetwork","txb","isDash","UInt16","versionSupportsDashSpecialTransactions","extraPayload","outs","forEach","txOut","addOutput","ins","txIn","__addInputUnsafe","index","sequence","addInput","txHash","vout","__canModifyInputs","from","reverse","getHash","options","isCoinbaseHash","prevTxOut","toString","scriptPubKey","__canModifyOutputs","toOutputScript","build","__build","buildIncomplete","clone","setInputScript","setWitness","__overMaximumFees","virtualSize","canSign","sign","TypeError","SIGHASH_ALL","publicKey","getPublicKeyBuffer","Satoshi","signatureHash","signed","fromRSBuffer","r","toCompact","toChunk","toScriptSignature","signatureHashType","buffer","readUInt8","SIGHASH_ANYONECANPAY","nInputs","nOutputs","hashTypeMod","SIGHASH_NONE","SIGHASH_SINGLE","bytes","incoming","reduce","a","outgoing","fee","feeRate","module","exports"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/@bitgo/utxo-lib/dist/src/transaction_builder.js"],"sourcesContent":["var Buffer = require('safe-buffer').Buffer;\nvar baddress = require('./address');\nvar bcrypto = require('./crypto');\nvar bscript = require('./script');\nvar btemplates = require('./templates');\nvar coins = require('./coins');\nvar networks = require('./networks');\nvar ops = require('bitcoin-ops');\nvar typeforce = require('typeforce');\nvar types = require('./types');\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [\n    btemplates.types.P2PKH,\n    btemplates.types.P2PK,\n    btemplates.types.MULTISIG,\n    btemplates.types.SMART_TRANSACTION\n];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\nvar ECPair = require('./ecpair');\nvar ECSignature = require('./ecsignature');\nvar Transaction = require('./transaction');\nvar SmartTransactionSignatures = require('./smart_transaction_signatures');\nvar SmartTransactionSignature = require('./smart_transaction_signature');\nvar getMainnet = require('./coins').getMainnet;\nvar debug = require('debug')('bitgo:utxolib:txbuilder');\nfunction supportedType(type) {\n    return SIGNABLE.indexOf(type) !== -1;\n}\nfunction supportedP2SHType(type) {\n    return P2SH.indexOf(type) !== -1;\n}\nfunction extractChunks(type, chunks, script) {\n    var pubKeys = [];\n    var signatures = [];\n    switch (type) {\n        case scriptTypes.P2PKH:\n            // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n            pubKeys = chunks.slice(1);\n            signatures = chunks.slice(0, 1);\n            break;\n        case scriptTypes.SMART_TRANSACTION:\n            signatures = [chunks[0]];\n            break;\n        case scriptTypes.P2PK:\n            pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n            signatures = chunks.slice(0, 1);\n            break;\n        case scriptTypes.MULTISIG:\n            if (script) {\n                var multisig = btemplates.multisig.output.decode(script);\n                pubKeys = multisig.pubKeys;\n            }\n            signatures = chunks.slice(1).map(function (chunk) {\n                return chunk.length === 0 ? undefined : chunk;\n            });\n            break;\n    }\n    return {\n        pubKeys: pubKeys,\n        signatures: signatures\n    };\n}\nfunction expandInput(scriptSig, witnessStack) {\n    if (scriptSig.length === 0 && witnessStack.length === 0)\n        return {};\n    var prevOutScript;\n    var prevOutType;\n    var scriptType;\n    var script;\n    var redeemScript;\n    var witnessScript;\n    var witnessScriptType;\n    var redeemScriptType;\n    var witness = false;\n    var p2wsh = false;\n    var p2sh = false;\n    var witnessProgram;\n    var chunks;\n    var scriptSigChunks = bscript.decompile(scriptSig);\n    var sigType = btemplates.classifyInput(scriptSigChunks, true);\n    if (sigType === scriptTypes.P2SH) {\n        p2sh = true;\n        redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n        redeemScriptType = btemplates.classifyOutput(redeemScript);\n        prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n        prevOutType = scriptTypes.P2SH;\n        script = redeemScript;\n    }\n    var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n    if (classifyWitness === scriptTypes.P2WSH) {\n        witnessScript = witnessStack[witnessStack.length - 1];\n        witnessScriptType = btemplates.classifyOutput(witnessScript);\n        p2wsh = true;\n        witness = true;\n        if (scriptSig.length === 0) {\n            prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n            prevOutType = scriptTypes.P2WSH;\n            if (redeemScript !== undefined) {\n                throw new Error('Redeem script given when unnecessary');\n            }\n            // bare witness\n        }\n        else {\n            if (!redeemScript) {\n                throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n            }\n            witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n            if (!redeemScript.equals(witnessProgram)) {\n                throw new Error('Redeem script didn\\'t match witnessScript');\n            }\n        }\n        if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n            throw new Error('unsupported witness script');\n        }\n        script = witnessScript;\n        scriptType = witnessScriptType;\n        chunks = witnessStack.slice(0, -1);\n    }\n    else if (classifyWitness === scriptTypes.P2WPKH) {\n        witness = true;\n        var key = witnessStack[witnessStack.length - 1];\n        var keyHash = bcrypto.hash160(key);\n        if (scriptSig.length === 0) {\n            prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n            prevOutType = scriptTypes.P2WPKH;\n            if (typeof redeemScript !== 'undefined') {\n                throw new Error('Redeem script given when unnecessary');\n            }\n        }\n        else {\n            if (!redeemScript) {\n                throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n            }\n            witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n            if (!redeemScript.equals(witnessProgram)) {\n                throw new Error('Redeem script did not have the right witness program');\n            }\n        }\n        scriptType = scriptTypes.P2PKH;\n        chunks = witnessStack;\n    }\n    else if (redeemScript) {\n        if (!supportedP2SHType(redeemScriptType)) {\n            throw new Error('Bad redeemscript!');\n        }\n        script = redeemScript;\n        scriptType = redeemScriptType;\n        chunks = scriptSigChunks.slice(0, -1);\n    }\n    else {\n        prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n        chunks = scriptSigChunks;\n    }\n    var expanded = extractChunks(scriptType, chunks, script);\n    var result = {\n        pubKeys: expanded.pubKeys,\n        signatures: expanded.signatures,\n        prevOutScript: prevOutScript,\n        prevOutType: prevOutType,\n        signType: scriptType,\n        signScript: script,\n        witness: Boolean(witness)\n    };\n    if (p2sh) {\n        result.redeemScript = redeemScript;\n        result.redeemScriptType = redeemScriptType;\n    }\n    if (p2wsh) {\n        result.witnessScript = witnessScript;\n        result.witnessScriptType = witnessScriptType;\n    }\n    return result;\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin, value, network) {\n    if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript)\n        return;\n    if (input.pubKeys.length === input.signatures.length)\n        return;\n    network = network || networks.bitcoin;\n    var unmatched = input.signatures.concat();\n    input.signatures = input.pubKeys.map(function (pubKey) {\n        var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n        var match;\n        // check for a signature\n        unmatched.some(function (signature, i) {\n            // skip if undefined || OP_0\n            if (!signature)\n                return false;\n            if (coins.isZcash(network) && value === undefined) {\n                return false;\n            }\n            // TODO: avoid O(n) hashForSignature\n            var parsed = ECSignature.parseScriptSignature(signature);\n            var hash = transaction.hashForSignatureByNetwork(vin, input.signScript, value, parsed.hashType, !!input.witness);\n            // skip if signature does not match pubKey\n            if (!keyPair.verify(hash, parsed.signature))\n                return false;\n            // remove matched signature from unmatched\n            unmatched[i] = undefined;\n            match = signature;\n            return true;\n        });\n        return match;\n    });\n}\nfunction expandOutput(script, scriptType, ourPubKey) {\n    typeforce(types.Buffer, script);\n    var scriptChunks = bscript.decompile(script);\n    if (!scriptType) {\n        scriptType = btemplates.classifyOutput(script);\n    }\n    var pubKeys = [];\n    switch (scriptType) {\n        // does our hash160(pubKey) match the output scripts?\n        case scriptTypes.P2PKH:\n            if (!ourPubKey)\n                break;\n            var pkh1 = scriptChunks[2];\n            var pkh2 = bcrypto.hash160(ourPubKey);\n            if (pkh1.equals(pkh2))\n                pubKeys = [ourPubKey];\n            break;\n        // does our hash160(pubKey) match the output scripts?\n        case scriptTypes.P2WPKH:\n            if (!ourPubKey)\n                break;\n            var wpkh1 = scriptChunks[1];\n            var wpkh2 = bcrypto.hash160(ourPubKey);\n            if (wpkh1.equals(wpkh2))\n                pubKeys = [ourPubKey];\n            break;\n        case scriptTypes.SMART_TRANSACTION:\n            if (!ourPubKey)\n                break;\n            pubKeys = [ourPubKey];\n            break;\n        case scriptTypes.P2PK:\n            pubKeys = scriptChunks.slice(0, 1);\n            break;\n        case scriptTypes.MULTISIG:\n            pubKeys = scriptChunks.slice(1, -2);\n            break;\n        default: return { scriptType: scriptType };\n    }\n    return {\n        pubKeys: pubKeys,\n        scriptType: scriptType,\n        signatures: pubKeys.map(function () { return undefined; })\n    };\n}\nfunction checkP2SHInput(input, redeemScriptHash) {\n    if (input.prevOutType) {\n        if (input.prevOutType !== scriptTypes.P2SH)\n            throw new Error('PrevOutScript must be P2SH');\n        var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n        if (!prevOutScriptScriptHash.equals(redeemScriptHash))\n            throw new Error('Inconsistent hash160(RedeemScript)');\n    }\n}\nfunction checkP2WSHInput(input, witnessScriptHash) {\n    if (input.prevOutType) {\n        if (input.prevOutType !== scriptTypes.P2WSH)\n            throw new Error('PrevOutScript must be P2WSH');\n        var scriptHash = bscript.decompile(input.prevOutScript)[1];\n        if (!scriptHash.equals(witnessScriptHash))\n            throw new Error('Inconsistent sha25(WitnessScript)');\n    }\n}\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n    var expanded;\n    var prevOutType;\n    var prevOutScript;\n    var p2sh = false;\n    var p2shType;\n    var redeemScriptHash;\n    var witness = false;\n    var p2wsh = false;\n    var witnessType;\n    var witnessScriptHash;\n    var signType;\n    var signScript;\n    if (redeemScript && witnessScript) {\n        redeemScriptHash = bcrypto.hash160(redeemScript);\n        witnessScriptHash = bcrypto.sha256(witnessScript);\n        checkP2SHInput(input, redeemScriptHash);\n        if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash)))\n            throw new Error('Witness script inconsistent with redeem script');\n        expanded = expandOutput(witnessScript, undefined, kpPubKey);\n        if (!expanded.pubKeys)\n            throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n        prevOutType = btemplates.types.P2SH;\n        prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n        p2sh = witness = p2wsh = true;\n        p2shType = btemplates.types.P2WSH;\n        signType = witnessType = expanded.scriptType;\n        signScript = witnessScript;\n    }\n    else if (redeemScript) {\n        redeemScriptHash = bcrypto.hash160(redeemScript);\n        checkP2SHInput(input, redeemScriptHash);\n        expanded = expandOutput(redeemScript, undefined, kpPubKey);\n        if (!expanded.pubKeys)\n            throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n        prevOutType = btemplates.types.P2SH;\n        prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n        p2sh = true;\n        signType = p2shType = expanded.scriptType;\n        signScript = redeemScript;\n        witness = signType === btemplates.types.P2WPKH;\n    }\n    else if (witnessScript) {\n        witnessScriptHash = bcrypto.sha256(witnessScript);\n        checkP2WSHInput(input, witnessScriptHash);\n        expanded = expandOutput(witnessScript, undefined, kpPubKey);\n        if (!expanded.pubKeys)\n            throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n        prevOutType = btemplates.types.P2WSH;\n        prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n        witness = p2wsh = true;\n        signType = witnessType = expanded.scriptType;\n        signScript = witnessScript;\n    }\n    else if (input.prevOutType) {\n        // embedded scripts are not possible without a redeemScript\n        if (input.prevOutType === scriptTypes.P2SH ||\n            input.prevOutType === scriptTypes.P2WSH) {\n            throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n        }\n        prevOutType = input.prevOutType;\n        prevOutScript = input.prevOutScript;\n        expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n        if (!expanded.pubKeys)\n            return;\n        witness = (input.prevOutType === scriptTypes.P2WPKH);\n        signType = prevOutType;\n        signScript = prevOutScript;\n    }\n    else {\n        prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n        expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n        prevOutType = scriptTypes.P2PKH;\n        witness = false;\n        signType = prevOutType;\n        signScript = prevOutScript;\n    }\n    if (signType === scriptTypes.P2WPKH) {\n        signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n    }\n    if (p2sh) {\n        input.redeemScript = redeemScript;\n        input.redeemScriptType = p2shType;\n    }\n    if (p2wsh) {\n        input.witnessScript = witnessScript;\n        input.witnessScriptType = witnessType;\n    }\n    input.pubKeys = expanded.pubKeys;\n    input.signatures = expanded.signatures;\n    input.signScript = signScript;\n    input.signType = signType;\n    input.prevOutScript = prevOutScript;\n    input.prevOutType = prevOutType;\n    input.witness = witness;\n}\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n    if (type === scriptTypes.P2PKH) {\n        if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1)\n            return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n    }\n    else if (type === scriptTypes.SMART_TRANSACTION) {\n        if (signatures.length === 1 && Buffer.isBuffer(signatures[0]))\n            return btemplates.smartTransaction.input.encodeStack(signatures[0]);\n    }\n    else if (type === scriptTypes.P2PK) {\n        if (signatures.length === 1 && Buffer.isBuffer(signatures[0]))\n            return btemplates.pubKey.input.encodeStack(signatures[0]);\n    }\n    else if (type === scriptTypes.MULTISIG) {\n        if (signatures.length > 0) {\n            signatures = signatures.map(function (signature) {\n                return signature || ops.OP_0;\n            });\n            if (!allowIncomplete) {\n                // remove blank signatures\n                signatures = signatures.filter(function (x) { return x !== ops.OP_0; });\n            }\n            return btemplates.multisig.input.encodeStack(signatures);\n        }\n    }\n    else {\n        throw new Error('Not yet supported');\n    }\n    if (!allowIncomplete)\n        throw new Error('Not enough signatures provided');\n    return [];\n}\nfunction buildInput(input, allowIncomplete) {\n    var scriptType = input.prevOutType;\n    var sig = [];\n    var witness = [];\n    if (supportedType(scriptType)) {\n        sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n    }\n    var p2sh = false;\n    if (scriptType === btemplates.types.P2SH) {\n        // We can remove this error later when we have a guarantee prepareInput\n        // rejects unsignable scripts - it MUST be signable at this point.\n        if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n            throw new Error('Impossible to sign this type');\n        }\n        if (supportedType(input.redeemScriptType)) {\n            sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        }\n        // If it wasn't SIGNABLE, it's witness, defer to that\n        if (input.redeemScriptType) {\n            p2sh = true;\n            scriptType = input.redeemScriptType;\n        }\n    }\n    switch (scriptType) {\n        // P2WPKH is a special case of P2PKH\n        case btemplates.types.P2WPKH:\n            witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n            break;\n        case btemplates.types.P2WSH:\n            // We can remove this check later\n            if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n                throw new Error('Impossible to sign this type');\n            }\n            if (supportedType(input.witnessScriptType)) {\n                witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n                witness.push(input.witnessScript);\n                scriptType = input.witnessScriptType;\n            }\n            break;\n    }\n    // append redeemScript if necessary\n    if (p2sh) {\n        sig.push(input.redeemScript);\n    }\n    return {\n        type: scriptType,\n        script: bscript.compile(sig),\n        witness: witness\n    };\n}\n// By default, assume is a bitcoin transaction\nfunction TransactionBuilder(network, maximumFeeRate) {\n    this.prevTxMap = {};\n    this.network = network || networks.bitcoin;\n    // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n    this.maximumFeeRate = maximumFeeRate || 2500;\n    this.inputs = [];\n    this.tx = new Transaction(this.network);\n}\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (this.inputs.some(function (input) {\n        if (!input.signatures)\n            return false;\n        return input.signatures.some(function (s) { return s; });\n    })) {\n        throw new Error('No, this would invalidate signatures');\n    }\n    this.tx.locktime = locktime;\n};\nTransactionBuilder.prototype.setVersion = function (version, overwinter) {\n    if (overwinter === void 0) { overwinter = true; }\n    typeforce(types.UInt32, version);\n    if (coins.isZcashCompatible(this.network)) {\n        if (!this.network.consensusBranchId.hasOwnProperty(this.tx.version)) {\n            /* istanbul ignore next */\n            throw new Error('Unsupported Zcash transaction');\n        }\n        this.tx.overwintered = (overwinter ? 1 : 0);\n        this.tx.consensusBranchId = this.network.consensusBranchId[version];\n    }\n    this.tx.version = version;\n};\nTransactionBuilder.prototype.setConsensusBranchId = function (consensusBranchId) {\n    if (!coins.isZcashCompatible(this.network)) {\n        throw new Error('consensusBranchId can only be set for Zcash or compatible transactions');\n    }\n    if (!this.inputs.every(function (input) {\n        if (input.prevOutType === scriptTypes.SMART_TRANSACTION) {\n            if (input.signatures === undefined || input.signatures.length === 0)\n                return true;\n            var smartTxSigs = SmartTransactionSignatures.fromChunk(bscript.decompile(input.signatures)[0]);\n            if (smartTxSigs.error != null ||\n                smartTxSigs.signatures.length === 0 ||\n                smartTxSigs.signatures.every(function (sig) { return sig.oneSignature.length === 0; })) {\n                return true;\n            }\n        }\n        return input.signatures === undefined;\n    })) {\n        /* istanbul ignore next */\n        throw new Error('Changing the consensusBranchId for a partially signed transaction would invalidate signatures');\n    }\n    typeforce(types.UInt32, consensusBranchId);\n    this.tx.consensusBranchId = consensusBranchId;\n};\nTransactionBuilder.prototype.setVersionGroupId = function (versionGroupId) {\n    if (!(coins.isZcashCompatible(this.network) && this.tx.isOverwinterCompatible())) {\n        throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' +\n            this.network.coin + ', version: ' + this.tx.version);\n    }\n    typeforce(types.UInt32, versionGroupId);\n    this.tx.versionGroupId = versionGroupId;\n};\nTransactionBuilder.prototype.setExpiryHeight = function (expiryHeight) {\n    if (!(coins.isZcashCompatible(this.network) && this.tx.isOverwinterCompatible())) {\n        throw new Error('expiryHeight can only be set for Zcash or compatible networks starting at overwinter version. Current network coin: ' +\n            this.network.coin + ', version: ' + this.tx.version);\n    }\n    typeforce(types.UInt32, expiryHeight);\n    this.tx.expiryHeight = expiryHeight;\n};\nTransactionBuilder.prototype.setJoinSplits = function (transaction) {\n    if (!(coins.isZcashCompatible(this.network) && this.tx.supportsJoinSplits())) {\n        throw new Error('joinsplits can only be set for Zcash or compatible networks starting at version 2. Current network coin: ' +\n            this.network.coin + ', version: ' + this.tx.version);\n    }\n    if (transaction && transaction.joinsplits) {\n        this.tx.joinsplits = transaction.joinsplits.map(function (txJoinsplit) {\n            return {\n                vpubOld: txJoinsplit.vpubOld,\n                vpubNew: txJoinsplit.vpubNew,\n                anchor: txJoinsplit.anchor,\n                nullifiers: txJoinsplit.nullifiers,\n                commitments: txJoinsplit.commitments,\n                ephemeralKey: txJoinsplit.ephemeralKey,\n                randomSeed: txJoinsplit.randomSeed,\n                macs: txJoinsplit.macs,\n                zproof: txJoinsplit.zproof,\n                ciphertexts: txJoinsplit.ciphertexts\n            };\n        });\n        this.tx.joinsplitPubkey = transaction.joinsplitPubkey;\n        this.tx.joinsplitSig = transaction.joinsplitSig;\n        return;\n    }\n    throw new Error('Invalid transaction with joinsplits');\n};\nTransactionBuilder.fromTransaction = function (transaction, network) {\n    var txbNetwork = network || networks.bitcoin;\n    var txb = new TransactionBuilder(txbNetwork);\n    if (getMainnet(txb.network) !== getMainnet(transaction.network)) {\n        throw new Error('This transaction is incompatible with the transaction builder');\n    }\n    // Copy transaction fields\n    txb.setVersion(transaction.version, transaction.overwintered);\n    txb.setLockTime(transaction.locktime);\n    if (coins.isZcashCompatible(txbNetwork)) {\n        // Copy Zcash overwinter fields. Omitted if the transaction builder is not for Zcash.\n        if (txb.tx.isOverwinterCompatible()) {\n            txb.setVersionGroupId(transaction.versionGroupId);\n            txb.setExpiryHeight(transaction.expiryHeight);\n        }\n        txb.setConsensusBranchId(transaction.consensusBranchId);\n    }\n    // Copy Dash special transaction fields. Omitted if the transaction builder is not for Dash.\n    if (coins.isDash(txbNetwork)) {\n        typeforce(types.UInt16, transaction.type);\n        txb.tx.type = transaction.type;\n        if (txb.tx.versionSupportsDashSpecialTransactions()) {\n            typeforce(types.Buffer, transaction.extraPayload);\n            txb.tx.extraPayload = transaction.extraPayload;\n        }\n    }\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(function (txOut) {\n        txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(function (txIn) {\n        txb.__addInputUnsafe(txIn.hash, txIn.index, {\n            sequence: txIn.sequence,\n            script: txIn.script,\n            witness: txIn.witness,\n            value: txIn.value\n        });\n    });\n    // fix some things not possible through the public API\n    txb.inputs.forEach(function (input, i) {\n        fixMultisigOrder(input, transaction, i, input.value, txbNetwork);\n    });\n    return txb;\n};\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n        throw new Error('No, this would invalidate signatures');\n    }\n    var value;\n    // is it a hex string?\n    if (typeof txHash === 'string') {\n        // transaction hashs's are displayed in reverse order, un-reverse it\n        txHash = Buffer.from(txHash, 'hex').reverse();\n        // is it a Transaction object?\n    }\n    else if (txHash instanceof Transaction) {\n        var txOut = txHash.outs[vout];\n        prevOutScript = txOut.script;\n        value = txOut.value;\n        txHash = txHash.getHash();\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n        sequence: sequence,\n        prevOutScript: prevOutScript,\n        value: value\n    });\n};\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n    if (Transaction.isCoinbaseHash(txHash)) {\n        throw new Error('coinbase inputs not supported');\n    }\n    var prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.prevTxMap[prevTxOut] !== undefined)\n        throw new Error('Duplicate TxOut: ' + prevTxOut);\n    var input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n        input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n        input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n        var prevOutType;\n        if (!input.pubKeys && !input.signatures) {\n            var expanded = expandOutput(options.prevOutScript);\n            if (expanded.pubKeys) {\n                input.pubKeys = expanded.pubKeys;\n                input.signatures = expanded.signatures;\n            }\n            prevOutType = expanded.scriptType;\n        }\n        input.prevOutScript = options.prevOutScript;\n        input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n    }\n    var vin = this.tx.addInput(txHash, vout, options.sequence, options.script);\n    this.inputs[vin] = input;\n    this.prevTxMap[prevTxOut] = vin;\n    return vin;\n};\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n        throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 address string\n    if (typeof scriptPubKey === 'string') {\n        scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.tx.addOutput(scriptPubKey, value);\n};\nTransactionBuilder.prototype.build = function () {\n    return this.__build(false);\n};\nTransactionBuilder.prototype.buildIncomplete = function () {\n    return this.__build(true);\n};\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n    if (!allowIncomplete) {\n        if (!this.tx.ins.length)\n            throw new Error('Transaction has no inputs');\n        if (!this.tx.outs.length)\n            throw new Error('Transaction has no outputs');\n    }\n    var tx = this.tx.clone();\n    // Create script signatures from inputs\n    this.inputs.forEach(function (input, i) {\n        var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n        if (!scriptType && !allowIncomplete)\n            throw new Error('Transaction is not complete');\n        var result = buildInput(input, allowIncomplete);\n        // skip if no result\n        if (!allowIncomplete) {\n            if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n                throw new Error(result.type + ' not supported');\n            }\n        }\n        tx.setInputScript(i, result.script);\n        tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n        // do not rely on this, its merely a last resort\n        if (this.__overMaximumFees(tx.virtualSize())) {\n            throw new Error('Transaction has absurd fees');\n        }\n    }\n    return tx;\n};\nfunction canSign(input) {\n    return (input.prevOutScript !== undefined &&\n        input.signScript !== undefined &&\n        input.pubKeys !== undefined &&\n        input.signatures !== undefined &&\n        input.signatures.length === input.pubKeys.length &&\n        input.pubKeys.length > 0 &&\n        (input.witness === false || (input.witness === true && input.value !== undefined)));\n}\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n    debug('Signing transaction: (input: %d, hashType: %d, witnessVal: %s, witnessScript: %j)', vin, hashType, witnessValue, witnessScript);\n    debug('Transaction Builder network: %j', this.network);\n    // TODO: remove keyPair.network matching in 4.0.0\n    if (keyPair.network && keyPair.network !== this.network)\n        throw new TypeError('Inconsistent network');\n    if (!this.inputs[vin])\n        throw new Error('No input at index: ' + vin);\n    hashType = hashType || Transaction.SIGHASH_ALL;\n    var input = this.inputs[vin];\n    // if redeemScript was previously provided, enforce consistency\n    if (input.redeemScript !== undefined &&\n        redeemScript &&\n        !input.redeemScript.equals(redeemScript)) {\n        throw new Error('Inconsistent redeemScript');\n    }\n    var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n    if (!canSign(input)) {\n        if (witnessValue !== undefined) {\n            if (input.value !== undefined && input.value !== witnessValue)\n                throw new Error('Input didn\\'t match witnessValue');\n            typeforce(types.Satoshi, witnessValue);\n            input.value = witnessValue;\n        }\n        debug('Preparing input %d for signing', vin);\n        if (!canSign(input))\n            prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n        if (!canSign(input))\n            throw Error(input.prevOutType + ' not supported');\n    }\n    // ready to sign\n    var signatureHash = this.tx.hashForSignatureByNetwork(vin, input.signScript, witnessValue, hashType, !!input.witness);\n    // enforce in order signing of public keys\n    var signed = input.pubKeys.some(function (pubKey, i) {\n        if (!kpPubKey.equals(pubKey))\n            return false;\n        if (input.signatures[i])\n            throw new Error('Signature already exists');\n        if (kpPubKey.length !== 33 &&\n            input.signType === scriptTypes.P2WPKH)\n            throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n        var signature = keyPair.sign(signatureHash);\n        if (Buffer.isBuffer(signature))\n            signature = ECSignature.fromRSBuffer(signature);\n        debug('Produced signature (r: %s, s: %s)', signature.r, signature.s);\n        if (input.signType === scriptTypes.SMART_TRANSACTION) {\n            input.signatures[i] = new SmartTransactionSignatures(1, 1, [\n                new SmartTransactionSignature(1, 1, pubKey, signature.toCompact().slice(1))\n            ]).toChunk();\n        }\n        else\n            input.signatures[i] = signature.toScriptSignature(hashType);\n        return true;\n    });\n    if (!signed)\n        throw new Error('Key pair cannot sign for this input');\n};\nfunction signatureHashType(buffer) {\n    return buffer.readUInt8(buffer.length - 1);\n}\nTransactionBuilder.prototype.__canModifyInputs = function () {\n    return this.inputs.every(function (input) {\n        // any signatures?\n        if (input.signatures === undefined)\n            return true;\n        return input.signatures.every(function (signature) {\n            if (!signature)\n                return true;\n            var hashType = signatureHashType(signature);\n            // if SIGHASH_ANYONECANPAY is set, signatures would not\n            // be invalidated by more inputs\n            return hashType & Transaction.SIGHASH_ANYONECANPAY;\n        });\n    });\n};\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n    var nInputs = this.tx.ins.length;\n    var nOutputs = this.tx.outs.length;\n    return this.inputs.every(function (input) {\n        if (input.signatures === undefined)\n            return true;\n        if (input.signType === scriptTypes.SMART_TRANSACTION) {\n            var smartTxSigs = SmartTransactionSignatures.fromChunk(bscript.decompile(input.signatures)[0]);\n            if (smartTxSigs.error != null ||\n                smartTxSigs.signatures.length === 0 ||\n                smartTxSigs.signatures.every(function (sig) { return sig.oneSignature.length === 0; })) {\n                return true;\n            }\n        }\n        return input.signatures.every(function (signature) {\n            if (!signature)\n                return true;\n            var hashType = signatureHashType(signature);\n            var hashTypeMod = hashType & 0x1f;\n            if (hashTypeMod === Transaction.SIGHASH_NONE)\n                return true;\n            if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n                // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n                // some signatures would be invalidated by the addition\n                // of more outputs\n                return nInputs <= nOutputs;\n            }\n        });\n    });\n};\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n    // not all inputs will have .value defined\n    var incoming = this.inputs.reduce(function (a, x) { return a + (x.value >>> 0); }, 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    var outgoing = this.tx.outs.reduce(function (a, x) { return a + x.value; }, 0);\n    var fee = incoming - outgoing;\n    var feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n};\nmodule.exports = TransactionBuilder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}